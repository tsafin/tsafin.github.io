---
layout: article
title: Московская встреча пользователей Си++ - часть 3
date: '2014-02-20T02:40:00.000+04:00'
author: Timur Safin
tags:
- с++
- Moscow C++ Users Group
modified_time: '2014-04-19T16:09:53.503+04:00'
thumbnail: http://4.bp.blogspot.com/-gYnHGyGcTK0/UwKGPK64GII/AAAAAAAAQa4/B9cl6Xp2bDc/s72-c/andrew_ivanitsky_linkedin.png
blogger_id: tag:blogger.com,1999:blog-1111089994103028505.post-2562753037865060012
blogger_orig_url: http://tsafin.blogspot.com/2014/02/moscow-c-users-group-3.html
---

<h3>Андрей Иванитский - <a href="http://www.meetingcpp.ru/cpp/cpp-moscow-2014/2%20Memory-Model.pdf">C++ Memory model</a></h3> <p><blockquote>Перед тем как говорить про собственно презентацию, немного о фирме Андрея Иванитского. Как мы потом узнали эта таинственная, неназванная фирма была спонсором Московского мероприятия. Но по каким-то причинам они предпочли не называть своего имени. Но мы не привыкли играть по таким правилам, потому я попытался найти того "Андрея Иванитского", который мог бы показаться релевантным здесь. Имея достаточно обширную сеть в Linkedin я попытался найти Андрея Иванитского там, и после нескольких фальстартов увидел 2 возможных кандидата </br>[Про размер сети сейчас сказать точно невозможно, т.к. linkedin некоторое время назад убил страницу статистики сети, но когда то они утверждали что круги 3-го порядка достигают у меня пару миллион контактов, что я расцениваю это как сеть, покрывающую большую часть российского программирования. За исключением самой дремучей его части, которые не завели себе профиля в LinkedIn.]  </br> <img src="http://4.bp.blogspot.com/-gYnHGyGcTK0/UwKGPK64GII/AAAAAAAAQa4/B9cl6Xp2bDc/s1600/andrew_ivanitsky_linkedin.png" width="100%" /> <br/>Второй Андрей Иванитский работает в IT подразделении Тандем, фармацевтической фирмы. Кажется не очень релевантным. Первый же является главой тренинг центра Naumen, и занимается XP, Agile и всем таким. Все кажется вполне релевантным, посему я предлагаю считать что это тренинг центр Naumen спонсировал данное собрание.  <br/> <b>За что ему отдельное большое спасибо!</b> </blockquote></p> <p>Но вернемся к материалам доклада. C++ memory model - не легкая тема. Не легкая и противоречивая. Мне кажется в этом отчасти виноват и сам Бьерн, т.к. он не лез в соответсвующие части и отдал на откуп Ханс Боэму (<a href="http://en.wikipedia.org/wiki/Boehm_garbage_collector">С/C++ garbage collector</a> помните?). Мне всегда казалось, что Ханс очень не любит простых путей, часто запутывая остальных. Понятно, что работа с памятью в многопроцессорной среде не может быть простой. Понятно, что работа с памятью в таком множестве различных архитектур, в каком поддерживается Си++, не может быть унифицировнным. Понятно, что в стандарте придется допускать расхождения в любую сторону. Но не <a href="http://stackoverflow.com/search?q=c%2B%2B11+%22memory+model%22">до такой же степени должно быть заморочено!</a></p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet" lang="ru"><p>Now we are moving to the 2nd slides by Andrey Ivanitsky on C++ model memory <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> <a href="https://twitter.com/search?q=%23Moscow&amp;src=hash">#Moscow</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434616959435419648">15 февраля 2014</a></blockquote><blockquote class="twitter-tweet" lang="ru"><p>synchronize-with and happens-before as order relationships in <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> memory model</p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434619929107509248">15 февраля 2014</a></blockquote><blockquote class="twitter-tweet" lang="ru"><p>memory orderings: sequenciallly consustent, acquire-release, and relaxed orderings <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> <a href="https://twitter.com/search?q=%23Moscow&amp;src=hash">#Moscow</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434620352732221440">15 февраля 2014</a></blockquote> <p>(Часто перечисление записанного мной в Твитере будет малосвязанным, т.к. полной ясности до сих пор нет. Уж извините!) Было рассказано про отношения порядка: synchronize-with и happens-before. При рассмотрении порядка доступа к памяти (memory ordering) были введены различные типы синхронизаций: sequenciallly consistent (консистентно для следующих друг за другом), acquire-release (захват, освобождение), и relaxed orderings ("расслабленное" упорядочивание).</p><blockquote class="twitter-tweet" lang="ru"><p>why there is no copy constructor for std::atomic&lt;&gt;? <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> <a href="https://twitter.com/search?q=%23MOSCOW&amp;src=hash">#MOSCOW</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434621636302475264">15 февраля 2014</a></blockquote><blockquote class="twitter-tweet" lang="ru"><p>Because they are sync primitives and copying such primitive is an indication you are doing something wrong <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434621751893323776">15 февраля 2014</a></blockquote><blockquote class="twitter-tweet" lang="ru"><p>Totall: Do not use relaxed memory ordering ! <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> <a href="https://twitter.com/search?q=%23moscow&amp;src=hash">#moscow</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434625084431413248">15 февраля 2014</a></blockquote><blockquote class="twitter-tweet" lang="ru"><p>Total: recommended to use hihger level promitives (std::future, packaged_tasks) and not low level primitives std::mutex/atomic</p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434625522123816960">15 февраля 2014</a></blockquote><p>Были даны обобщенные советы, чтобы аудитория никогда не использовала relaxed ordering, и вообще не заморачивалась про memory ordering и блокировки, а лучше использовала высокоуровневые примитивы типа std::future или packaged_tasks. На что Григорий Демченко (предыдущий докладчик про synca библиотеку) разумно возразил что ему не заморачиваться не удается, и в жизни такое часто.</p> <blockquote class="twitter-tweet" lang="ru"><p>Немножко запутал, конечно, аудиторию докладчик про memory ordering <a href="https://twitter.com/search?q=%23cpp&amp;src=hash">#cpp</a> <a href="https://twitter.com/search?q=%23moscow&amp;src=hash">#moscow</a> <a href="https://twitter.com/search?q=%23usergroup&amp;src=hash">#usergroup</a></p>&mdash; Timur Safin (40+) (@tsafin) <a href="https://twitter.com/tsafin/statuses/434627215758618624">15 февраля 2014</a></blockquote> <p>Подводя итог, могу заметить что Андрей Иванитский затронул важную, мало освещенную, мало понимаемую часть стандарта Си++. Но проблема в том, что, очевидно, эта часть еще им самим не хорошо была изучена, и как результат ясности понимания у аудитории не возникло. С другой стороны, важная часть эффекта все же была достигнута - меня и многих других этот доклад заставил заглянуть в стандарт и соответствующие материалы группы WG21. Надеюсь в будущем это позволит вновь вернуться к данному вопросу и рассказать о нем уже с практической точки зрения, но уже на новом уровне понимания.</p> <p><i><a href="/2014/02/moscow-c-users-group-4.html">Продолжение следует...</a></i></p>