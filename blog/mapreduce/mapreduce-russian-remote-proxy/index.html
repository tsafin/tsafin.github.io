<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Удаленное прокси может быть не (очень) больно • Timur Safin - Making No Sense</title>
    <meta name="description" content="(Динамическая диспетчеризация спешит на помощь)

">
    <meta name="keywords" content="">
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="Удаленное прокси может быть не (очень) больно">
	<meta name="twitter:description" content="(Динамическая диспетчеризация спешит на помощь)

">
	<meta name="twitter:site" content="@tsafin">
	<meta name="twitter:creator" content="@tsafin">
	
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:image" content="/images/landscapes/feature1.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Удаленное прокси может быть не (очень) больно">
	<meta property="og:description" content="(Динамическая диспетчеризация спешит на помощь)

">
	<meta property="og:url" content="/blog/mapreduce/mapreduce-russian-remote-proxy/">
	<meta property="og:site_name" content="Timur Safin - Making No Sense">

    <link rel="canonical" href="/blog/mapreduce/mapreduce-russian-remote-proxy/">

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Timur Safin - Making No Sense Atom Feed">
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <link rel="stylesheet" href="/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="/js/vendor/html5shiv.min.js"></script>
      <script src="/js/vendor/respond.min.js"></script>
    <![endif]-->
  </head>

  <body id="js-body">
    <!--[if lt IE 9]><div class="upgrade notice-warning"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

    <header id="masthead">
  <div class="inner-wrap">
    <a href="/" class="site-title">Timur Safin - Making No Sense</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Timur Safin - Making No Sense</a></li>
	 
      
      <li><a href="/blog/">Articles</a></li>
    
      
      <li><a href="/projects/">Projects</a></li>
    
      
      <li><a href="/resume/">About</a></li>
    
</ul>
    </nav>
  </div>
<!-- /.inner-wrap -->
</header><!-- /.masthead -->
    <nav role="navigation" id="js-menu" class="sliding-menu-content">
  <h5>Timur Safin - Making No Sense <span>Table of Contents</span>
</h5>
  <ul class="menu-item">
    <li>
      <a href="/blog/">
        
        <div class="title">Articles</div>
        <p class="excerpt">Blog posts and random rumblings...</p>
      </a>
    </li>
<li>
      <a href="/projects/">
        
        <div class="title">Projects</div>
        <p class="excerpt">Open-source projects</p>
      </a>
    </li>
<li>
      <a href="/resume/">
        
        <div class="title">About</div>
        <p class="excerpt">Resume and such...</p>
      </a>
    </li>
  </ul>
</nav>
<button type="button" id="js-menu-trigger" class="sliding-menu-button lines-button x2" role="button" aria-label="Toggle Navigation">
  <span class="nav-lines"></span>
</button>

<div id="js-menu-screen" class="menu-screen"></div>


    <div id="page-wrapper">
      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="/images/landscapes/feature1.jpg" class="page-feature-image" alt="Удаленное прокси может быть не (очень) больно" itemprop="image">
				
			</div>
<!-- /.page-image -->
		</div>
<!-- /.page-feature -->
		
		
<nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://tsafin.net" itemprop="url">
        <span itemprop="title">Home</span>
    </a> ›
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="/blog/" itemprop="url">
        <span itemprop="title">Blog</span>
    </a>
    </span>
</span></nav>
<!-- /.breadcrumbs -->


<div class="breadcrumbs sm">
    <a href="https://habrahabr.ru/company/intersystems/blog/314774/" itemprop="url">
        https://habrahabr.ru/company/intersystems/blog/314774/ <span class="glyphicon glyphicon-share" aria-hidden="true"></span>
    </a>
</div>

		<div class="page-title">
			<h1>Удаленное прокси может быть не (очень) больно</h1>
		</div>
		<div class="inner-wrap">
			<div id="content" class="page-content" itemprop="articleBody">
				<h2 id="динамическая-диспетчеризация-спешит-на-помощь">(Динамическая диспетчеризация спешит на помощь)</h2>

<p>После нескольких статей про <strong>MapReduce</strong> нам показалось необходимым еще раз отойти в сторону и поговорить про инфраструктуру, которая поможет облегчить построение решения MapReduce. Мы, по-прежнему, говорим про <strong>InterSystems Caché</strong>, и, по-прежнему, пытаемся построить <strong>MapReduce</strong> систему на базе имеющихся в системе подручных материалов.</p>

<p>На определенном этапе написания системы, типа <strong>MapReduce</strong>, встает задача удобного вызова удаленных методов и процедур (например, посылка управляющих сообщений с контроллера на сторону управляемых узлов). В среде Caché есть несколько простых, но не очень удобных методов достичь этой цели, тогда как хочется бы получить <em>именно удобный</em>.</p>

<p>Хочется взять простой и последовательный код, тут и там вызывающий методы объекта или класса, и волшебным мановением руки сделать его работающим уже с удаленными методами. Конечно же, степень “удаленности” может быть различной, мы, например, можем просто вызывать методы в другом процессе того же самого узла, суть от этого сильно не поменяется - нам нужно получить удобный способ маршаллизации вызовов “на ту сторону” вовне текущего процесса, работающего в <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GORIENT_ch_enviro">текущей области</a>.</p>

<p>После нескольких фальстартов автор вдруг осознал, что в Caché ObjectScript есть очень простой механизм, который позволит скрыть все низкоуровневые детали под удобной, высокоуровневой оболочкой - это <em>механизм динамической диспетчеризации методов и свойств</em>.</p>

<p>Если оглянуться (далеко) назад, то можно увидеть, что начиная с Caché 5.2 (а это на минуточку с 2007 года) в базовом классе  <a href="http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;LIBRARY=ENSLIB&amp;CLASSNAME=%25RegisteredObject"><code class="highlighter-rouge">%RegisteredObject</code></a> есть несколько предопределенных методов, наследуемых каждым объектом в системе, которые вызываются при попытке вызова неизвестного во время компиляции метода или свойства (в настоящий момент эти методы переехали в интерфейс <a href="http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;LIBRARY=ENSLIB&amp;CLASSNAME=%25Library.SystemBase"><code class="highlighter-rouge">%Library.SystemBase</code></a> но это сильно не поменяло сути) .</p>

<table>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchMethod (Method As %String, Args...)</code></td>
      <td>Вызов неизвестного метода или доступ к неизвестному многомерному свойству (их синтаксис идентичен)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ClassMethod %DispatchClassMethod (Class As %String, Method As %String, Args...)</code></td>
      <td>Вызов неизвестного метода класса для заданного класса</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchGetProperty (Property As %String)</code></td>
      <td>Чтение неизвестного свойства</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchSetProperty (Property As %String, Val)</code></td>
      <td>Запись в неизвестное свойство</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchSetMultidimProperty (Property As %String, Val, Subs...)</code></td>
      <td>Запись в неизвестное многомерное свойство (<em>не используется в данном случае, будет частью другой истории</em>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchGetModified (Property As %String)</code></td>
      <td>Доступ к флагу “modified” (“изменен”) для неизвестного свойства (<em>также, не используется в данной истории</em>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Method %DispatchSetModified (Property As %String, Val)</code></td>
      <td>Дополнение к методу выше - запись в флаг “modified” (“изменен”) для неизвестного свойства (<em>не используется в данной истории</em>)</td>
    </tr>
  </tbody>
</table>

<p>Для простоты эксперимента, мы будем использовать только функции, отвечающие за вызов неизвестных методов и скалярных свойств. В продуктовой среде вам на определенном этапе может понадобиться переопределить все или большинство описанных методов, т.ч. будьте бдительны.</p>

<h2 id="сначала-попроще---протоколирующий-объект-прокси">Сначала попроще - протоколирующий объект-прокси</h2>

<p>Напомним, что ещё со времен “царя Гороха” в стандартной библиотеке CACHELIB были стандартные методы и классы для работы с проекцией JavaScript объектов в XEN -  <a href="http://docs.intersystems.com/Cach%C3%A920161/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;LIBRARY=%25SYS&amp;CLASSNAME=%25ZEN.proxyObject"><code class="highlighter-rouge">%ZEN.proxyObject</code></a>, он позволял манипулировать динамическими свойствами даже во времена, когда еще не было работ по документной базе DocumentDB (не спрашивайте) и тем более не было нативной поддержки JSON объектов в ядре среды Caché.</p>

<p>Давайте, для затравки, попытаемся создать простой, <em>протоколирующий все вызовы, прокси объект</em>? Где мы обернем все вызовы через динамическую диспетчеризацию с сохранением протокола о каждом произошедшем событии. [Очень похоже на технику mocking в других языковых средах.]
[[Как это переводить на русский? “мОкать”?]]</p>

<p>В качестве примера возьмем сильно упрощенный класс <code class="highlighter-rouge">Sample.SimplePerson</code> (по странному стечению обстоятельств очень похожего на <code class="highlighter-rouge">Sample.Person</code> из области SAMPLES в стандартной поставке <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"> )</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:15:23:32:MAPREDUCE&gt;set p = ##class(Sample.SimplePerson).%OpenId(2)

DEVLATEST:15:23:34:MAPREDUCE&gt;zw p

p=&lt;OBJECT REFERENCE&gt;[1@Sample.SimplePerson]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.SimplePerson
|           %%OID: $lb("2","Sample.SimplePerson")
| reference count: 2
+----------------- attribute values ------------------
|       %Concurrency = 1  &lt;Set&gt;
|                Age = 9
|           Contacts = 23
|               Name = "Waal,Nataliya Q."
+-----------------------------------------------------
</code></pre></div></div>

<p>Т.е. имеем персистентный класс - с 3-мя простыми свойствами: Age, Contacts и Name. Обернем доступ ко всем свойствам этого класса и вызов всех его методов в своем классе <code class="highlighter-rouge">Sample.LoggingProxy</code>, и каждый такой вызов или доступ к свойству  будем протоколировать … куда-нибудь.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Простой протоколирующий прокси объект:
Class Sample.LoggingProxy Extends %RegisteredObject
{
/// Кладем лог доступа в глобал
Parameter LoggingGlobal As %String = "^Sample.LoggingProxy";
/// Храним ссылку на открытый объект 
Property OpenedObject As %RegisteredObject;

/// просто сохраняем строку как следующий узел в глобале
ClassMethod Log(Value As %String)
{
    #dim gloRef = ..#LoggingGlobal
    set @gloRef@($sequence(@gloRef)) = Value
}

/// Более удобный метод с префиксом и аргументами
ClassMethod LogArgs(prefix As %String, args...)
{
    #dim S as %String = $get(prefix) _ ": " _ $get(args(1))
    #dim i as %Integer
    for i=2:1:$get(args) {
        set S = S_","_args(i)
    }
    do ..Log(S)
}

/// открыть экземпляр другого класса с заданным %ID
ClassMethod %CreateInstance(className As %String, %ID As %String) As Sample.LoggingProxy
{
    #dim wrapper = ..%New()
    set wrapper.OpenedObject = $classmethod(className, "%OpenId", %ID)
    return wrapper
}

/// запротоколировать переданные аргументы и передать управление через прокси ссылку
Method %DispatchMethod(methodName As %String, args...)
{
    do ..LogArgs(methodName, args...)
    return $method(..OpenedObject, methodName, args...)
}

/// запротоколировать переданные аргументы и прочитать свойство через прокси ссылку
Method %DispatchGetProperty(Property As %String)
{
    #dim Value as %String = $property(..OpenedObject, Property)
    do ..LogArgs(Property, Value)
    return Value
}

/// запротоколировать переданные аргументы и записать свойство через прокси ссылку
/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchSetProperty(Property, Value As %String)
{
    do ..LogArgs(Property, Value)
    set $property(..OpenedObject, Property) = Value
}

}
</code></pre></div></div>

<ol>
  <li>Параметр класса <code class="highlighter-rouge">#LoggingGlobal</code> задаёт имя глобала, где будем хранить лог (в данном случае в глобале с именем <code class="highlighter-rouge">^Sample.LogginGlobal</code>);</li>
  <li>Есть два простых метода <code class="highlighter-rouge">Log(Arg)</code> и <code class="highlighter-rouge">LogArgs(prefix, args...)</code> которые пишут протокол в глобал, заданный свойством выше;</li>
  <li>
<code class="highlighter-rouge">%DispatchMethod</code>, <code class="highlighter-rouge">%DispatchGetProperty</code> и <code class="highlighter-rouge">%DispatchSetProperty</code> обрабатывают соответствующие сценарии с вызовами неизвестного метода или обращения к свойству. Они протоколируют через <code class="highlighter-rouge">LogArgs</code> каждый случай обращения, а затем напрямую вызывают метод или свойство объекта из ссылки <code class="highlighter-rouge">..%OpenedObject</code>;</li>
  <li>Также там задан метод “фабрики класса” <code class="highlighter-rouge">%CreateInstance</code>, который открывает экземпляр заданного класса по его идентификатору <code class="highlighter-rouge">%ID</code>. Созданный объект “оборачивается” в объект <code class="highlighter-rouge">Sample.LogginProxy</code>, ссылка на которого и возвращается из этого метода класса.</li>
</ol>

<p><img alt="Logging Proxy Draw" src="/assets/remote-proxy/LoggingProxySample.png"></p>

<p>Никакого шаманства, ничего особенного, но уже в этих 70 строках Caché ObjectScript мы попытались показать шаблон вызова метода/свойства с <em>побочным эффектом</em> (более полезный пример такого шаблона будет показан ниже).</p>

<p>Давайте посмотрим как ведет себя наш “протоколирущий прокси объект”:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:15:25:11:MAPREDUCE&gt;set w =
## class(Sample.LoggingProxy).%CreateInstance("Sample.SimplePerson", 2)

DEVLATEST:15:25:32:MAPREDUCE&gt;zw w
w=&lt;OBJECT REFERENCE&gt;[1@Sample.LoggingProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.LoggingProxy
| reference count: 2
+----------------- attribute values ------------------
|           (none)
+----------------- swizzled references ---------------
|     i%OpenedObject = ""
|     r%OpenedObject = [2@Sample.SimplePerson](mailto:2@MR.Sample.AgeAverage.Person)
+-----------------------------------------------------
DEVLATEST:15:25:34:MAPREDUCE&gt;w w.Age
9

DEVLATEST:15:25:41:MAPREDUCE&gt;w w.Contacts
23

DEVLATEST:15:25:49:MAPREDUCE&gt;w w.Name
Waal,Nataliya Q.

DEVLATEST:15:26:16:MAPREDUCE&gt;zw ^Sample.LoggingProxy
^Sample.LoggingProxy=4
^Sample.LoggingProxy(1)="Age: 9"
^Sample.LoggingProxy(2)="Contacts: 23"
^Sample.LoggingProxy(3)="Name: Waal,Nataliya Q."
</code></pre></div></div>

<p>Мы получили состояние экземпляра класса <code class="highlighter-rouge">Sample.SimplePerson</code>, доступного через прокси, и результаты протоколирования, сохраненные в глобал при доступе к свойствам прокси объекта. Все как и ожидалось.</p>

<h2 id="прокси-удаленного-объекта">Прокси удаленного объекта</h2>

<p>Внимательный читатель все еще должен помнить для чего мы тут собрались - все эти упражнения нужны нам для реализации простого прокси объекта, отображающего объект на удаленном узле кластера. На самом деле, класс с релевантной функциональностью в Caché есть - это <a href="http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;LIBRARY=%25sys&amp;CLASSNAME=%25Net.RemoteConnection"><code class="highlighter-rouge">%Net.RemoteConnection</code></a>. Что с ним может быть не так?</p>

<p><em>Многое</em> (и то, что класс официально помечен как “deprecated” - не находится в списке наших претензий, у нас вопросы другого рода).</p>

<p>Как многие знают, класс <a href="http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;LIBRARY=%25sys&amp;CLASSNAME=%25Net.RemoteConnection"><code class="highlighter-rouge">%Net.RemoteConnection</code></a> использует c-binding для вызова удаленных методов Caché, который, в свою очередь, являются оберткой над <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GBCP_intro">cpp-binding</a>. Если вам известен адрес системы, область с которой вы хотите работать, и знаете логин и пароль, то у вас есть все для удаленного вызова метода в этой области этого узла. Проблема с данным API из <code class="highlighter-rouge">%Net.RemoteConnection</code> - оно очень громоздко и многословно:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Class MR.Sample.TestRemoteConnection Extends %RegisteredObject
{

ClassMethod TestMethod(Arg As %String) As %String
{
    quit $zu(5)_"^"_##class(%SYS.System).GetInstanceName()_"^"_
         $i(^MR.Sample.TestRemoteConnectionD)
}

ClassMethod TestLocal()
{
    #dim connection As %Net.RemoteConnection = ##class(%Net.RemoteConnection).%New()
    #dim status As %Status = connection.Connect("127.0.0.1",$zu(5),^%SYS("SSPort"),"_SYSTEM","SYS")
    set status = connection.ResetArguments()
    set status = connection.AddArgument("Hello", 0 /*by ref*/, $$$cbindStringId)
    #dim rVal As %String = ""
    set status = connection.InvokeClassMethod(..%ClassName(1), "TestMethod", .rVal, 1 /*has return*/, $$$cbindStringId)
    zw rVal
    do connection.Disconnect()
}

...

}
</code></pre></div></div>

<p>После создания соединения, и перед вызовом метода класса вы должны собственноручно озаботиться передачей списка аргументов, начиная с вызова <code class="highlighter-rouge">ResetArguments</code>, и далее передавать каждый следующий аргумент через вызов <code class="highlighter-rouge">AddArgument</code>, не забывая о куче неясных, низкоуровневых параметров, описывающих аргумент, (например, его тип в номенклатуре cpp-binding, тип аргумента, входной или выходной и многое другое).</p>

<p>Также, персонально, меня сильно расстраивало, что нельзя было просто вернуть значение после вызова удаленного метода (т.к. возвращаемое значение <code class="highlighter-rouge">InvokeClassMethod</code> является просто кодом состояния, и для простого возврата скалярного значения из функции, ты собственноручно должен был сам позаботиться о соответствующем типе возвращаемого  аргумента при передаче длинного списка параметров).</p>

<p><em>Я слишком стар для таких многословных и долгих предварительных игр!</em></p>

<p><em>В идеале мне хотелось получить короткий и простой метод передачи параметров в удаленную функцию, работающую на другой машине или в другой области.</em></p>

<p>Помните в Caché ObjectScript есть метод передачи переменного числа параметров через массив <code class="highlighter-rouge">args...</code> в аргументах функции? Почему бы не поиспользовать такой механизм для скрытия всех этих грязных деталей низкоуровневого интерфейса, оставив нам просто название и список аргументов? И чтобы движок все сделал сам (догадавшись о типе передаваемых данных, например)?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Пример прокси удаленного объекта посредством %Net.RemoteConnection
Class Sample.RemoteProxy Extends %RegisteredObject
{
Property RemoteConnection As %Net.RemoteConnection [Internal ];
Property LastStatus As %Status [InitialExpression = {$$$OK}];

Method %OnNew() As %Status
{
    set ..RemoteConnection = ##class(%Net.RemoteConnection).%New()

    return $$$OK
}

/// создать экземпляр указанного класса 
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%CreateInstance(className)
}

/// открыть экземпляр заданного класса по его %ID
Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%OpenObjectId(className, Id)
}

/// Соединение с системой посредством объекта конфигуратора 
/// { "IP": IP, "Namespace" : Namespace, ... }
Method %Connect(Config As %Object) As Sample.RemoteProxy
{
    #dim sIP As %String = Config.IP
    #dim sNamespace As %String = Config.Namespace
    #dim sPort As %String = Config.Port
    #dim sUsername As %String = Config.Username
    #dim sPassword As %String = Config.Password
    #dim sClientIP As %String = Config.ClientIP
    #dim sClientPort As %String = Config.ClientPort
    
    if sIP = "" { set sIP = "127.0.0.1" }
    if sPort = "" { set sPort = ^%SYS("SSPort") }
    set ..LastStatus = ..RemoteConnection.Connect(sIP, sNamespace, sPort, 
                                                  sUsername, sPassword, 
                                                  sClientIP, sClientPort)
    
    return $this
}

ClassMethod ApparentlyClassName(CompoundName As %String, Output ClassName As %String, Output MethodName As %String) As %Boolean [Internal ]
{
    #dim returnValue As %Boolean = 0
    
    if $length(CompoundName, "::") &gt; 1 {
        set ClassName = $piece(CompoundName, "::", 1)
        set MethodName = $piece(CompoundName, "::", 2, *)

        return 1
    } elseif $length(CompoundName, "'") &gt; 1 {
        set ClassName = $piece(CompoundName, "'", 1)
        set MethodName = $piece(CompoundName, "'", 2, *)

        return 1
    }

    return 0
}

/// Динамическая диспетчеризация метода (класса) удаленного объекта
Method %DispatchMethod(methodName As %String, args...)
{
    #dim className as %String = ""
    
    if ..ApparentlyClassName(methodName, .className, .methodName) {
        return ..InvokeClassMethod(className, methodName, args...)
    }
    return 1
}

/// собственно вызов метода класса со всеми низкоуровневыми деталями
Method InvokeClassMethod(ClassName As %String, MethodName As %String, args...)
{
    #dim returnValue = ""
    #dim i as %Integer
    do ..RemoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = ..RemoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = ..RemoteConnection.InvokeClassMethod(ClassName, MethodName, .returnValue, $quit)
    return returnValue
}

}
</code></pre></div></div>

<p><img alt="Remote Proxy Draw" src="/assets/remote-proxy/RemoteProxy.png"></p>

<p>При проектировании данного интерфейса мы внесли несколько модных идиом, которые должны были послужить упрощению интерфейса взаимодействия, уменьшению размера кода, который надо писать, и, при возможности, увеличению стабильности интерфейса.</p>

<p>Первое такое упрощение, которое мы пытались внести в интерфейс - это использование <em>объекта конфигуратора</em> для передачи <em>именованных аргументов</em> внутрь функции вместо их длинного списка. В Caché ObjectScript нет (ещё) встроенного способа передать <a href="http://perldesignpatterns.com/?NamedArguments"><em>именованные аргументы</em></a>, и если, например, вам требуется передать только последние два аргумента из длинного списка параметров функции, то вам надо аккуратненько отсчитать запятые параметров которые вас не интересуют и передать в конце желаемое. Прямо скажем, крайне хрупкая конструкция.</p>

<p>С другой стороны, с недавних пор в ObjectScript есть встроенная поддержка JSON объектов, которые можно создавать на лету, внутри выражения <code class="highlighter-rouge">{}</code>. Мы можем по примеру Perl, попытаться переиспользовать такие динамически создаваемые объекты (в случае с Perl это был хеш) для передачи именованных аргументов функции. Динамический объект конфигуратор может содержать только те ключи-значения, которые нас интересуют.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:16:27:18:MAPREDUCE&gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({"Namespace":"SAMPLES", "Username":"_SYSTEM", "Password":"SYS"})
 
DEVLATEST:16:27:39:MAPREDUCE&gt;zw w
w=&lt;OBJECT REFERENCE&gt;[1@Sample.RemoteProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.RemoteProxy
| reference count: 2
+----------------- attribute values ------------------
|         LastStatus = 1
+----------------- swizzled references ---------------
|           i%Config = ""
|           r%Config = ""
| i%RemoteConnection = ""
| r%RemoteConnection = 2@%Net.RemoteConnection
+-----------------------------------------------------
</code></pre></div></div>
<blockquote>
  <p>Да, согласен, конструкция получается еще не настолько прозрачная, как получалась в Perl, т.к. все равно присутствуют дополнительные, обрамляющие объект фигурные скобки, но это уже путь в нужном направлении</p>
</blockquote>

<p>Вторая современная идиома, введенная в данном примере - каскадирование вызовов. Где это только было возможным мы возвращали из методов ссылку на текущий объект <code class="highlighter-rouge">%this</code>, что позволяло вызывать несколько методов этого же класса в виде каскада.</p>

<p>Меньше кода пишем - лучше спим.</p>

<h3 id="проблема-вызова-метода-класса">Проблема вызова метода класса</h3>

<p>Созданный нами объект оболочка, инкапсулирующий функциональность <code class="highlighter-rouge">Net.RemoteConnection</code>, в текущем его состоянии не может сделать многого, чтобы мы хотели. Если нет места для хранения контекста создаваемого объекта… (Пока нет, Мы решим данную проблему позже, в другом классе) Единственное, что мы можем попытаться сделать сейчас, на текущем уровне абстракции и при текущем дизайне оболочки - это упростить способ вызова методов класса, вызываемых без ссылки на экземпляр объекта.</p>

<p>Можем попытаться переопределить <code class="highlighter-rouge">%DispatchClassMethod</code>, но это в нашем случае сильно не поможет - мы хотим написать <em>обобщенный</em> прокси класс, который бы работал для <em>любого</em> удаленного класса. В случае простого отношения 1:1, когда некая специализированная оболочка на нашей стороне соответствует определенному классу на той стороне, такой подход с переопределением <code class="highlighter-rouge">%DispatchClassMethod</code> вполне сработает, но … не для обобщенного класса.</p>

<blockquote>
  <p>В общем случае, нам надо будет придумать что-то другое, но, желательно, по прежнему, простое, что работало бы с любым соединением и любым целевым классом.</p>
</blockquote>

<p>Наше, достаточно элегантное решение данной проблемы мы приведем ниже, а пока отойдем в сторону и посмотрим, что в Caché ObjectScript может использоваться в качестве идентификатора метода или свойства. Не все знают (я, по крайней мере, узнал об этом пару лет назад) что имена идентификаторов в ObjectScript могут состоять не только из латинских букв и цифр, но и любых “символов алфавита” заданных текущей локалью (например, не только латинские буквы A-Za-z и арабские цифры 0-9, но и кириллические буквы А-Яа-я, <em>при установленной Русской локали</em>). [<a href="http://stackoverflow.com/questions/35452352/what-characters-are-usable-in-a-variable-name-in-objectscript-on-a-unicode-ins/35492721#35492721">эта проблема вскользь обсуждалось в данной дискуссии на StackOverflow</a>] Более того, если продолжать извращаться, то вы можете вставить в имя идентификатора любые эмодзи символы в качестве разделителя, <em>если вы создадите и активируете такую локаль</em>, где эмодзи считались бы буквенными символами в текущем языке. В целом, всё же кажется, что любой, чувствительный к установленной локали трюк, не очень далеко полетит и не подходит как обобщенное решение, т.ч. давайте остановимся.</p>

<p>… С другой стороны, идея использования некоего символа разделителя внутри имени метода (класса) кажется вполне разумной и многообещающей. Мы могли бы скрыть обработку разделителя внутри специальной реализации  <code class="highlighter-rouge">%DispatchMethod</code>, где бы мы отделяли название класса от имени метода, и соответственно передавали управление в нужный метод класс, скрывая все детали реализации.</p>

<p>Так, пожалуй, и сделаем.</p>

<p>Возвращаясь к синтаксису допустимых имен методов, еще менее известным фактом является факт, что вы можете записать в метод класса <em>вообще все что пожелаете</em> если поместите такое имя внутри двойных кавычек “”. Скомбинировав “закавыченность” имени и специальный разделитель для имени класса я мог бы, например, вызывать метод класса <code class="highlighter-rouge">LogicalToDisplay</code> из класса <code class="highlighter-rouge">Cinema.Duration</code> пользуясь следующим, непривычным на первый взгляд, синтаксисом:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:16:27:41:MAPREDUCE&gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({"Namespace":"SAMPLES", "Username":"_SYSTEM", "Password":"SYS"})

DEVLATEST:16:51:39:MAPREDUCE&gt;write w."Cinema.Duration::LogicalToDisplay"(200)
3h20m
</code></pre></div></div>

<blockquote>
  <p><em>Выглядит немного странно, но крайне просто и компактно, не правда ли?</em></p>
</blockquote>

<p>Специальная обработка имени и распознавание разделителей происходит в функции <code class="highlighter-rouge">ApparentlyClassName</code>, где мы ищем специальные символы в качестве разделителя между <em>именем класса</em> и названием <em>метода класса</em> - такими разделителями были выбраны “::” (двойное двоеточие как в Си++) или “’” (одинарная кавычка как в Ada или первоначальном Perl-е).</p>

<p>Заметим, что не стоит пытаться вывести что-либо на экран при таком удаленном методе класса - весь результат выдачи потеряется (проигнорируется), т.к. протокол cpp-binding не перехватывает выдачу на экран, и не возвращает её обратно, вызывающей стороне.</p>

<p><em>Протокол cpp-binding возвращает скалярные данные, а не побочные эффекты</em>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:16:51:47:MAPREDUCE&gt;do w."Sample.Person::PrintPersons"(1)

</code></pre></div></div>

<h3 id="прокси-удаленных-объектов">Прокси удаленных объектов</h3>

<p>Пока что мы не делали много полезного в коде <code class="highlighter-rouge">Sample.RemoteProxy</code>, приведенном выше: мы только создавали соединение, и пробрасывали вызовы методов класса.</p>

<p>Если же вам надо создавать удаленные экземпляры классов или, паче чаяния, открывать объекты по их %ID, то вы можете воспользоваться сервисами другого нашего класса оболочки <code class="highlighter-rouge">%Sample.RemoteProxy.Object</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Class Sample.RemoteProxy.Object Extends %RegisteredObject
{
/// хранит ссылку на открытый объект для последующих манипуляций
Property OpenedObject As %Binary;
Property Owner As Sample.RemoteProxy [ Internal ];
Property LastStatus As %Status [ InitialExpression = {$$$OK}, Internal ];

Method RemoteConnection() As %Net.RemoteConnection [ CodeMode = expression ]
{
..Owner.RemoteConnection
}

Method %OnNew(owner As Sample.RemoteProxy) As %Status
{
    set ..Owner = owner
    return $$$OK
}

/// создаём новый экземпляр определенного класса
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = ""
    set ..LastStatus = ..RemoteConnection().CreateInstance(className, .pObject)
    set ..OpenedObject = ""
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

/// создаём экземпляр определенного класса при заданном %ID
Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = ""
    set ..LastStatus = ..RemoteConnection().OpenObjectId(className, Id, .pObject)
    set ..OpenedObject = ""
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

/// исполнить метод открытого объекта с переданными аргументами
Method InvokeMethod(MethodName As %String, args...) [ Internal ]
{
    #dim returnValue = ""
    #dim i as %Integer
    #dim remoteConnection = ..RemoteConnection()
    do remoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = remoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = remoteConnection.InvokeInstanceMethod(..OpenedObject, MethodName, .returnValue, $quit)
    return returnValue
}

/// Динамическая диспетчеризация метода (класса) удаленного объекта
Method %DispatchMethod(methodName As %String, args...)
{
    //do ..LogArgs(methodName, args...)
    return ..InvokeMethod(methodName, args...)
}

/// Динамическая диспетчеризация чтения свойства удаленного объекта
Method %DispatchGetProperty(Property As %String)
{
    #dim value = ""
    set ..LastStatus = ..RemoteConnection().GetProperty(..OpenedObject, Property, .value)
    return value
}

/// Динамическая диспетчеризация записи в свойство удаленного объекта
Method %DispatchSetProperty(Property, Value As %String) As %Status
{
   set ..LastStatus = ..RemoteConnection().SetProperty(..OpenedObject, Property, Value)
    return ..LastStatus
}

}
</code></pre></div></div>

<p><img alt="Remote Instance Method" src="/assets/remote-proxy/RemoteInstanceMethod.png"></p>

<p>Если приглядеться, то можно распознать что в коде оболочки объекта по прежнему используется общий класс <code class="highlighter-rouge">Sample.RemoteProxy</code>, соединяющий нас с низкоуровневыми примитивами cpp-binding (в данном случае <code class="highlighter-rouge">%Net.RemoteConnection</code>). Каждый создаваемый экземпляр удаленного объекта инстанцирует экземпляр класса <code class="highlighter-rouge">Sample.RemoteProxy.Object</code>, внутри которого хранится ссылка на свойство <code class="highlighter-rouge">..Owner</code> типа <code class="highlighter-rouge">Sample.RemoteProxy</code> которое и используется для всяких соединительных целей. Данное свойство инициализируется в момент создания объекта из конструктора (смотри <code class="highlighter-rouge">%OnNew</code>).</p>

<p>Мы также создали (относительно) удобный метод  <code class="highlighter-rouge">InvokeMethod</code>, который может работать с любым количеством передаваемых аргументов, и который маршаллизирует данные через <code class="highlighter-rouge">%Net.RemoteConnection</code> в вызовы удаленных методов (ну, т.е. как и было в оригинальном примере с <code class="highlighter-rouge">%Net.RemoteConnection</code> он вызывает <code class="highlighter-rouge">ResetArguments</code> перед началом заполнения списка аргументов и, в последующем, вызывает <code class="highlighter-rouge">AddArgument</code> для каждого следующего аргумента, и заканчивая это все вызовом <code class="highlighter-rouge">%NetRemoteConnection::InvokeInstanceMethod</code> для исполнения на “той стороне”)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEVLATEST:19:23:54:MAPREDUCE&gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({"Namespace":"SAMPLES", "Username":"_SYSTEM", "Password":"SYS"})

…

DEVLATEST:19:23:56:MAPREDUCE&gt;set p = w.%OpenObjectId("Sample.Person",1)

DEVLATEST:19:24:05:MAPREDUCE&gt;write p.Name
Quince,Maria B.
DEVLATEST:19:24:11:MAPREDUCE&gt;write p.SSN
369-27-1697
DEVLATEST:19:24:17:MAPREDUCE&gt;write p.Addition(1,2)
3
</code></pre></div></div>

<p>В данном примере мы присоединяемся к локальной системе и её области “SAMPLES”, открываем экземпляр класса <code class="highlighter-rouge">Sample.Person</code> по идентификатору 1, прочитываем его свойства (Name, SSN) и выполняем методы (Addition).</p>

<blockquote>
  <p>Таким образом, при правильном применении иерархии классов и механизмов языка, мы получаем простые и читабельные конструкции, вызывающие удаленный код, сохранив оригинальную семантику, но на порядок уменьшив количество требуемого кода.</p>
</blockquote>

<h3 id="вместо-заключения">Вместо заключения</h3>

<p>Код, приведенный в наших примерах, не имеет еще продуктового качества (там нет правильной обработки ошибок, нет обработки разрывов соединения или удаления коллекции объектов, но, даже сейчас, такой маленький и простой набор классов позволит вам писать <em>читабельный и легко поддерживаемый</em> код, оперирующий удаленными объектами на узлах кластера или в других областях конфигурации. Причем, значительно меньшими усилиями, и на порядок меньшим количеством строк.</p>

<p>Чем мы и воспользуемся при написании кода MapReduce в следующих частях саги…</p>

<p>Весь код, упомянутый здесь, доступен через <a href="https://gist.github.com/tsafin/02bb6b5967cbdd1176618cb645445770">gist</a>.</p>

				<hr>
				<footer class="page-footer">
					

<div class="author-image">
    <img src="/images/tsafin_twitter_small_logo.jpg" alt="Timur Safin">
</div>
<!-- ./author-image -->
<div class="author-content">
    <h3 class="author-name">Written by <span itemprop="author">Timur Safin</span>
</h3>
    <p class="author-bio"></p>
</div>
<!-- ./author-content -->
					<div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8%20%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%BD%D0%B5%20(%D0%BE%D1%87%D0%B5%D0%BD%D1%8C)%20%D0%B1%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE&amp;url=/blog/mapreduce/mapreduce-russian-remote-proxy/&amp;via=tsafin" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> Share on Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=/blog/mapreduce/mapreduce-russian-remote-proxy/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> Share on Facebook</a>
	<a class="btn-social google-plus" href="https://plus.google.com/share?url=/blog/mapreduce/mapreduce-russian-remote-proxy/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> Share on Google+</a>
</div>
<!-- /.share-this -->

					<div class="page-meta">
	<p>Updated <time datetime="2016-11-14T13:00:00Z" itemprop="datePublished">November 14, 2016</time></p>
</div>
<!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					<hr>
<div id="disqus_thread"></div>
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname = 'tsafin-net';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

				</aside>
			</div>
<!-- /.content -->
		</div>
<!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div>
<!-- /#main -->

      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="/">Home</a></li>
		
      
			<li><a href="/blog/">Articles</a></li>
		
      
			<li><a href="/projects/">Projects</a></li>
		
      
			<li><a href="/about/">About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">© 2020 <a href="http://tsafin.net">Timur Safin - Making No Sense</a> powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> + <a href="http://mmistakes.github.io/skinny-bones-jekyll/" rel="nofollow">Skinny Bones</a>.</p>
</footer>

    </div>

    <script src="/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="/js/main.js"></script>

    

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-84704404-1', 'auto');
  ga('require', 'linkid');
  ga('send', 'pageview');

</script>


<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter40768979 = new Ya.Metrika({
                    id:40768979,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/40768979" style="position:absolute; left:-9999px;" alt=""></div></noscript>
<!-- /Yandex.Metrika counter -->



  </body>

</html>
