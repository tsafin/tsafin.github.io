<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://tsafin.net/atom.xml" rel="self" type="application/atom+xml" /><link href="http://tsafin.net/" rel="alternate" type="text/html" /><updated>2020-02-26T23:33:59+00:00</updated><id>http://tsafin.net/atom.xml</id><title type="html">Timur Safin - Making No Sense</title><subtitle>Try to be public. Again</subtitle><entry><title type="html">Еще одна история про бинарную трансляцию</title><link href="http://tsafin.net/blog/jit/aot/bt/Eshche-odna-istoriya-pro-binarnuyu-translyaciyu-04-07/" rel="alternate" type="text/html" title="Еще одна история про бинарную трансляцию" /><published>2019-04-07T07:00:00+00:00</published><updated>2019-04-07T07:00:00+00:00</updated><id>http://tsafin.net/blog/jit/aot/bt/Eshche-odna-istoriya-pro-binarnuyu-translyaciyu-04-07</id><content type="html" xml:base="http://tsafin.net/blog/jit/aot/bt/Eshche-odna-istoriya-pro-binarnuyu-translyaciyu-04-07/">&lt;p&gt;Так получилось, что воскресным вечером 7 апреля дискуссия в @procxx плавно перешла от HPC# компилятора к JIT, и от него к бинарной трансляции, где я не преминул заметить, что&lt;/p&gt;

&lt;p&gt;&lt;em&gt;В одной из прошлых жизней, участвовал я в одном таком бабаяновском проекте, где на входе был x86 а на выходе - хмм, некий широкий, многострендовый код. Короче, не работает такая хрень, даже если закрыть глаза на энергию затраченную на JIT, обычно не хватает ширины памяти&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Люди, наиболее близкие к Java тусовке приняли это близко к сердцу, и потребовали объяснений. Давайте попытаемся…&lt;/p&gt;

&lt;p&gt;[Сразу оговорюсь, что в том проекте Б.А.Бабаяна я был простым Си++ программистом, членом команды памяти в симуляторе, и не принимал архитектурных решений.]&lt;/p&gt;

&lt;p&gt;Итак, мы говорим, про некий проект процессора, реализующего парадигму hardware-software co-design, назовем его V&lt;em&gt;, который внутри не является развитием x86 процессоров, но снаружи всячески пытается таковым выглядеть. Более-менее современным примером похожей реализации будет Transmeta Дейва Дитцела (купленной Интелом), в Software Machines (также купленной недавно Интелом), x86 compatibility layer в Itanium (созданной Интелом сначала в аппаратной форме, а потом перенесенной в софт), или такой же уровень совместимости с x86 в Elbrus (собственно реализованный примерно теми же людьми, что позже делали бинарную трансляцию в процессоре V&lt;/em&gt; в Интеле, или БТ в SoftwareMachines). Еще заметим, что из перечисленных, некоторые процессоры могут показывать свою внутреннюю архитектуру вовне (как Elbrus) и для них возможна нативная трансляция, а некоторые полностью таковую скрывали (Transmeta или наш V*).&lt;/p&gt;

&lt;p&gt;Предполагалось, что при всех прочих, мы бы брали x86 chipset со всеми его заморочками и стартовали систему “без глобальных” изменений. При начальной загрузке мы могли применять интерпретацию x86 кода, при загрузке в гипервизор у нас уже использовался бы JIT (очень простой и неэффективный) и потом, при запуске приложений, через систему обратной связи (здесь как раз шла смычка hardware-software) процессор сообщал транслятору о горячих трассах и происходила перекомпиляция (еще раз) со всеми включенными, специфичными для приложения, оптимизациями. Насколько я понимаю, примерно также происходила работа в Transmeta и вот эти несколько уровней трансляции выстраивались в иерархию multiple gears:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;interpreter&lt;/li&gt;
  &lt;li&gt;just-in-time translator&lt;/li&gt;
  &lt;li&gt;optimized compiler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Накладные расходы на интерпретатор в данной схеме минимальны - подкачали целевой код, исполнили инструкция за инструкцией. В силу специфики применения бинарной трансляции на таком внешнем, не x86 процессоре, JIT транслировал с минимум оптимизаций, так как он не должен заметно задерживать исполнение  x86 программы (ну или, как минимум, пользователь не должен заметить такой задержки). И только в режиме оптимизирующей ретрансляции мы можем не оглядываться на время, и соптимизировать в сторонке более достойно (ну в смысле как достойно, насколько позволяет целевая архитектура).&lt;/p&gt;

&lt;p&gt;У процессора V, также как и у Трансметы, Итаниума, и Эльбруса, был один первородный изъян - они оперировали очень широкими словами - помните VLIW, EPIC? Такой тип архитектур работает хорошо, только если закрыть глаза на трафик в память. А дешевого трафика в память не бывает - при прочих равных, у процессора на x86 и V* (да и на современном ARM) будут похожие параметры bandwidth в память. И если твоя архитектура имеет очень рыхлые средние параметры команд (что-то вроде, 0.5 V* длинной команды на линию кеша - против 4 x86 команд на ту же линию), то и проигрывать в такте выкачки команд ты будешь также. Твои программы будут во столько же раз толще, и оказывать во столько же большую нагрузку на память.&lt;/p&gt;

&lt;p&gt;Вторым первородным изъяном таких систем (и тут мы уже возвращаемся к первоначальному вопросу) был негласный тезис, что накладные расходы на JIT/оптимизатор пренебрежимо малы. Что гипервизор с трансляторами не ест электричества, не ест процессор. А это нихрена не так (и даже вроде не 10% а сильно больше, в зависимости от того эффекта в оптимизациях, который вы хотите получить). Этот overhead можно было бы нивелировать, если реализовать персистентность оттранслированного целевого кода, по примеру Alpha FX!32 (хотя в нашем случае это не было так элегантно как в FX!32, когда бинарно оттранслированный код просто сохранялся в те же EXE-шники, и вроде бы предполагалось некое внешнее хранилище, но я тут могу ошибаться). В итоге получается: ты платишь процессорным временем и энергией, или меньшим процессорным временем, но стореджем.&lt;/p&gt;

&lt;p&gt;Уходя немного в сторону от бинарной-трансляции в процессорах, к just-in-time трансляторам общего назначения заметим, что сторонники JIT в современных управляемых языках утверждают, что тот, в отличие от ahead-of-time (AOT) транслятора, имеет информацию о целевом процессоре и может сделать что-то лучше. Но это была бы какая-то странная игра в поддавки. Назовите мне хоть одну причину, почему программу с AOT нельзя при установке или на билд-машине откомпилировать с тем же самым знанием о целевом процессоре? Допустим у вас свой собственный маленький датацентр, cколько видов процессора у вас там работает? Обычно, в хорошо управляемом ДЦ, 1-3 (скажем Haswell, Broadwell, и немного Skylake). Скажите мне хоть одну причину почему я должен выбирать generic процессор, а не целевой HSW, и векторизовать уже с AVX2? (Еще и не факт, что JIT система умеет AVX2, AVX512, это обычно скрыто от программиста на managed языках) Также утверждается, что JIT может “пессимизировать” не такой горячий код, но зачем это если в AOT сценарии мы можем потратить немного больше времени, чем JIT может себе позволить, и соптимизировать даже холодный код? Там, где branch-predictor в процессоре не справится, мы можем собрать информацию о карте исполнения и перекомпилировать с PGO. В теории, PGO сценарий &lt;em&gt;может&lt;/em&gt; работать прозрачно и в JIT системе (и многие в это верят), но опять же, из-за изначальных ограничений у JIT, тот не может тратить на оптимизации больше заданного времени, и всегда будет проигрывать AOT на целевой машине с фидбеком (PGO).&lt;/p&gt;

&lt;p&gt;Уверен (надеюсь), что за то время, как система JIT развивается в современных managed средах (JVM, .NET), а это что-то за более чем 20 лет развития, они наконец-то научились переиспользовать результаты трансляции сделанной ранее. Но меня по-прежнему смущает вот это всё: все входные параметры инвариантны, железка та же, процессор тот же, ОС та же, какого хрена каждый раз, &lt;em&gt;каждый долбанный раз&lt;/em&gt;, когда запускается программа, транслировать её в целевой x86 или ARM? Надеясь получить что - другой процессор, другие модули включенные на исполнении, почему это не сделать один раз при скачивании/установке на данный компьютер/телефон?&lt;/p&gt;

&lt;p&gt;(Почему, например, Google Play, зная целевой процессор моего телефона, сразу не компилирует и не оптимизирует все скачиваемые программы и не отдает их нативно? Он думает телефон это сделает быстрее/лучше? Работая от батареи то)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;И вообще, когда все параметры формулы (программы/процессор/ОС) инвариантны, зачем делать что-то несколько (много) раз и не сделать это 1 раз? Через AOT&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Так получилось, что воскресным вечером 7 апреля дискуссия в @procxx плавно перешла от HPC# компилятора к JIT, и от него к бинарной трансляции, где я не преминул заметить, что</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature10.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Удаленное прокси может быть не (очень) больно</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-russian-remote-proxy/" rel="alternate" type="text/html" title="Удаленное прокси может быть не (очень) больно" /><published>2016-11-14T13:00:00+00:00</published><updated>2016-11-14T13:00:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-russian-remote-proxy</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-russian-remote-proxy/">&lt;h2 id=&quot;динамическая-диспетчеризация-спешит-на-помощь&quot;&gt;(Динамическая диспетчеризация спешит на помощь)&lt;/h2&gt;

&lt;p&gt;После нескольких статей про &lt;strong&gt;MapReduce&lt;/strong&gt; нам показалось необходимым еще раз отойти в сторону и поговорить про инфраструктуру, которая поможет облегчить построение решения MapReduce. Мы, по-прежнему, говорим про &lt;strong&gt;InterSystems Caché&lt;/strong&gt;, и, по-прежнему, пытаемся построить &lt;strong&gt;MapReduce&lt;/strong&gt; систему на базе имеющихся в системе подручных материалов.&lt;/p&gt;

&lt;p&gt;На определенном этапе написания системы, типа &lt;strong&gt;MapReduce&lt;/strong&gt;, встает задача удобного вызова удаленных методов и процедур (например, посылка управляющих сообщений с контроллера на сторону управляемых узлов). В среде Caché есть несколько простых, но не очень удобных методов достичь этой цели, тогда как хочется бы получить &lt;em&gt;именно удобный&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Хочется взять простой и последовательный код, тут и там вызывающий методы объекта или класса, и волшебным мановением руки сделать его работающим уже с удаленными методами. Конечно же, степень “удаленности” может быть различной, мы, например, можем просто вызывать методы в другом процессе того же самого узла, суть от этого сильно не поменяется - нам нужно получить удобный способ маршаллизации вызовов “на ту сторону” вовне текущего процесса, работающего в &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GORIENT_ch_enviro&quot;&gt;текущей области&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;После нескольких фальстартов автор вдруг осознал, что в Caché ObjectScript есть очень простой механизм, который позволит скрыть все низкоуровневые детали под удобной, высокоуровневой оболочкой - это &lt;em&gt;механизм динамической диспетчеризации методов и свойств&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Если оглянуться (далеко) назад, то можно увидеть, что начиная с Caché 5.2 (а это на минуточку с 2007 года) в базовом классе  &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=ENSLIB&amp;amp;CLASSNAME=%25RegisteredObject&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%RegisteredObject&lt;/code&gt;&lt;/a&gt; есть несколько предопределенных методов, наследуемых каждым объектом в системе, которые вызываются при попытке вызова неизвестного во время компиляции метода или свойства (в настоящий момент эти методы переехали в интерфейс &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=ENSLIB&amp;amp;CLASSNAME=%25Library.SystemBase&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%Library.SystemBase&lt;/code&gt;&lt;/a&gt; но это сильно не поменяло сути) .&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchMethod (Method As %String, Args...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Вызов неизвестного метода или доступ к неизвестному многомерному свойству (их синтаксис идентичен)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassMethod %DispatchClassMethod (Class As %String, Method As %String, Args...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Вызов неизвестного метода класса для заданного класса&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchGetProperty (Property As %String)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Чтение неизвестного свойства&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetProperty (Property As %String, Val)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Запись в неизвестное свойство&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetMultidimProperty (Property As %String, Val, Subs...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Запись в неизвестное многомерное свойство (&lt;em&gt;не используется в данном случае, будет частью другой истории&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchGetModified (Property As %String)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Доступ к флагу “modified” (“изменен”) для неизвестного свойства (&lt;em&gt;также, не используется в данной истории&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetModified (Property As %String, Val)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Дополнение к методу выше - запись в флаг “modified” (“изменен”) для неизвестного свойства (&lt;em&gt;не используется в данной истории&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Для простоты эксперимента, мы будем использовать только функции, отвечающие за вызов неизвестных методов и скалярных свойств. В продуктовой среде вам на определенном этапе может понадобиться переопределить все или большинство описанных методов, т.ч. будьте бдительны.&lt;/p&gt;

&lt;h2 id=&quot;сначала-попроще---протоколирующий-объект-прокси&quot;&gt;Сначала попроще - протоколирующий объект-прокси&lt;/h2&gt;

&lt;p&gt;Напомним, что ещё со времен “царя Гороха” в стандартной библиотеке CACHELIB были стандартные методы и классы для работы с проекцией JavaScript объектов в XEN -  &lt;a href=&quot;http://docs.intersystems.com/Caché20161/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25ZEN.proxyObject&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ZEN.proxyObject&lt;/code&gt;&lt;/a&gt;, он позволял манипулировать динамическими свойствами даже во времена, когда еще не было работ по документной базе DocumentDB (не спрашивайте) и тем более не было нативной поддержки JSON объектов в ядре среды Caché.&lt;/p&gt;

&lt;p&gt;Давайте, для затравки, попытаемся создать простой, &lt;em&gt;протоколирующий все вызовы, прокси объект&lt;/em&gt;? Где мы обернем все вызовы через динамическую диспетчеризацию с сохранением протокола о каждом произошедшем событии. [Очень похоже на технику mocking в других языковых средах.]
[[Как это переводить на русский? “мОкать”?]]&lt;/p&gt;

&lt;p&gt;В качестве примера возьмем сильно упрощенный класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.SimplePerson&lt;/code&gt; (по странному стечению обстоятельств очень похожего на &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.Person&lt;/code&gt; из области SAMPLES в стандартной поставке :wink: )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:15:23:32:MAPREDUCE&amp;gt;set p = ##class(Sample.SimplePerson).%OpenId(2)

DEVLATEST:15:23:34:MAPREDUCE&amp;gt;zw p

p=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.SimplePerson]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.SimplePerson
|           %%OID: $lb(&quot;2&quot;,&quot;Sample.SimplePerson&quot;)
| reference count: 2
+----------------- attribute values ------------------
|       %Concurrency = 1  &amp;lt;Set&amp;gt;
|                Age = 9
|           Contacts = 23
|               Name = &quot;Waal,Nataliya Q.&quot;
+-----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Т.е. имеем персистентный класс - с 3-мя простыми свойствами: Age, Contacts и Name. Обернем доступ ко всем свойствам этого класса и вызов всех его методов в своем классе &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.LoggingProxy&lt;/code&gt;, и каждый такой вызов или доступ к свойству  будем протоколировать … куда-нибудь.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// Простой протоколирующий прокси объект:
Class Sample.LoggingProxy Extends %RegisteredObject
{
/// Кладем лог доступа в глобал
Parameter LoggingGlobal As %String = &quot;^Sample.LoggingProxy&quot;;
/// Храним ссылку на открытый объект 
Property OpenedObject As %RegisteredObject;

/// просто сохраняем строку как следующий узел в глобале
ClassMethod Log(Value As %String)
{
    #dim gloRef = ..#LoggingGlobal
    set @gloRef@($sequence(@gloRef)) = Value
}

/// Более удобный метод с префиксом и аргументами
ClassMethod LogArgs(prefix As %String, args...)
{
    #dim S as %String = $get(prefix) _ &quot;: &quot; _ $get(args(1))
    #dim i as %Integer
    for i=2:1:$get(args) {
        set S = S_&quot;,&quot;_args(i)
    }
    do ..Log(S)
}

/// открыть экземпляр другого класса с заданным %ID
ClassMethod %CreateInstance(className As %String, %ID As %String) As Sample.LoggingProxy
{
    #dim wrapper = ..%New()
    set wrapper.OpenedObject = $classmethod(className, &quot;%OpenId&quot;, %ID)
    return wrapper
}

/// запротоколировать переданные аргументы и передать управление через прокси ссылку
Method %DispatchMethod(methodName As %String, args...)
{
    do ..LogArgs(methodName, args...)
    return $method(..OpenedObject, methodName, args...)
}

/// запротоколировать переданные аргументы и прочитать свойство через прокси ссылку
Method %DispatchGetProperty(Property As %String)
{
    #dim Value as %String = $property(..OpenedObject, Property)
    do ..LogArgs(Property, Value)
    return Value
}

/// запротоколировать переданные аргументы и записать свойство через прокси ссылку
/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchSetProperty(Property, Value As %String)
{
    do ..LogArgs(Property, Value)
    set $property(..OpenedObject, Property) = Value
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Параметр класса &lt;code class=&quot;highlighter-rouge&quot;&gt;#LoggingGlobal&lt;/code&gt; задаёт имя глобала, где будем хранить лог (в данном случае в глобале с именем &lt;code class=&quot;highlighter-rouge&quot;&gt;^Sample.LogginGlobal&lt;/code&gt;);&lt;/li&gt;
  &lt;li&gt;Есть два простых метода &lt;code class=&quot;highlighter-rouge&quot;&gt;Log(Arg)&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;LogArgs(prefix, args...)&lt;/code&gt; которые пишут протокол в глобал, заданный свойством выше;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchMethod&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchGetProperty&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchSetProperty&lt;/code&gt; обрабатывают соответствующие сценарии с вызовами неизвестного метода или обращения к свойству. Они протоколируют через &lt;code class=&quot;highlighter-rouge&quot;&gt;LogArgs&lt;/code&gt; каждый случай обращения, а затем напрямую вызывают метод или свойство объекта из ссылки &lt;code class=&quot;highlighter-rouge&quot;&gt;..%OpenedObject&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Также там задан метод “фабрики класса” &lt;code class=&quot;highlighter-rouge&quot;&gt;%CreateInstance&lt;/code&gt;, который открывает экземпляр заданного класса по его идентификатору &lt;code class=&quot;highlighter-rouge&quot;&gt;%ID&lt;/code&gt;. Созданный объект “оборачивается” в объект &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.LogginProxy&lt;/code&gt;, ссылка на которого и возвращается из этого метода класса.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img alt=&quot;Logging Proxy Draw&quot; src=&quot;/assets/remote-proxy/LoggingProxySample.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Никакого шаманства, ничего особенного, но уже в этих 70 строках Caché ObjectScript мы попытались показать шаблон вызова метода/свойства с &lt;em&gt;побочным эффектом&lt;/em&gt; (более полезный пример такого шаблона будет показан ниже).&lt;/p&gt;

&lt;p&gt;Давайте посмотрим как ведет себя наш “протоколирущий прокси объект”:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:15:25:11:MAPREDUCE&amp;gt;set w =
## class(Sample.LoggingProxy).%CreateInstance(&quot;Sample.SimplePerson&quot;, 2)

DEVLATEST:15:25:32:MAPREDUCE&amp;gt;zw w
w=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.LoggingProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.LoggingProxy
| reference count: 2
+----------------- attribute values ------------------
|           (none)
+----------------- swizzled references ---------------
|     i%OpenedObject = &quot;&quot;
|     r%OpenedObject = [2@Sample.SimplePerson](mailto:2@MR.Sample.AgeAverage.Person)
+-----------------------------------------------------
DEVLATEST:15:25:34:MAPREDUCE&amp;gt;w w.Age
9

DEVLATEST:15:25:41:MAPREDUCE&amp;gt;w w.Contacts
23

DEVLATEST:15:25:49:MAPREDUCE&amp;gt;w w.Name
Waal,Nataliya Q.

DEVLATEST:15:26:16:MAPREDUCE&amp;gt;zw ^Sample.LoggingProxy
^Sample.LoggingProxy=4
^Sample.LoggingProxy(1)=&quot;Age: 9&quot;
^Sample.LoggingProxy(2)=&quot;Contacts: 23&quot;
^Sample.LoggingProxy(3)=&quot;Name: Waal,Nataliya Q.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы получили состояние экземпляра класса &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.SimplePerson&lt;/code&gt;, доступного через прокси, и результаты протоколирования, сохраненные в глобал при доступе к свойствам прокси объекта. Все как и ожидалось.&lt;/p&gt;

&lt;h2 id=&quot;прокси-удаленного-объекта&quot;&gt;Прокси удаленного объекта&lt;/h2&gt;

&lt;p&gt;Внимательный читатель все еще должен помнить для чего мы тут собрались - все эти упражнения нужны нам для реализации простого прокси объекта, отображающего объект на удаленном узле кластера. На самом деле, класс с релевантной функциональностью в Caché есть - это &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25sys&amp;amp;CLASSNAME=%25Net.RemoteConnection&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt;&lt;/a&gt;. Что с ним может быть не так?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Многое&lt;/em&gt; (и то, что класс официально помечен как “deprecated” - не находится в списке наших претензий, у нас вопросы другого рода).&lt;/p&gt;

&lt;p&gt;Как многие знают, класс &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25sys&amp;amp;CLASSNAME=%25Net.RemoteConnection&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt;&lt;/a&gt; использует c-binding для вызова удаленных методов Caché, который, в свою очередь, являются оберткой над &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GBCP_intro&quot;&gt;cpp-binding&lt;/a&gt;. Если вам известен адрес системы, область с которой вы хотите работать, и знаете логин и пароль, то у вас есть все для удаленного вызова метода в этой области этого узла. Проблема с данным API из &lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt; - оно очень громоздко и многословно:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.TestRemoteConnection Extends %RegisteredObject
{

ClassMethod TestMethod(Arg As %String) As %String
{
    quit $zu(5)_&quot;^&quot;_##class(%SYS.System).GetInstanceName()_&quot;^&quot;_
         $i(^MR.Sample.TestRemoteConnectionD)
}

ClassMethod TestLocal()
{
    #dim connection As %Net.RemoteConnection = ##class(%Net.RemoteConnection).%New()
    #dim status As %Status = connection.Connect(&quot;127.0.0.1&quot;,$zu(5),^%SYS(&quot;SSPort&quot;),&quot;_SYSTEM&quot;,&quot;SYS&quot;)
    set status = connection.ResetArguments()
    set status = connection.AddArgument(&quot;Hello&quot;, 0 /*by ref*/, $$$cbindStringId)
    #dim rVal As %String = &quot;&quot;
    set status = connection.InvokeClassMethod(..%ClassName(1), &quot;TestMethod&quot;, .rVal, 1 /*has return*/, $$$cbindStringId)
    zw rVal
    do connection.Disconnect()
}

...

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После создания соединения, и перед вызовом метода класса вы должны собственноручно озаботиться передачей списка аргументов, начиная с вызова &lt;code class=&quot;highlighter-rouge&quot;&gt;ResetArguments&lt;/code&gt;, и далее передавать каждый следующий аргумент через вызов &lt;code class=&quot;highlighter-rouge&quot;&gt;AddArgument&lt;/code&gt;, не забывая о куче неясных, низкоуровневых параметров, описывающих аргумент, (например, его тип в номенклатуре cpp-binding, тип аргумента, входной или выходной и многое другое).&lt;/p&gt;

&lt;p&gt;Также, персонально, меня сильно расстраивало, что нельзя было просто вернуть значение после вызова удаленного метода (т.к. возвращаемое значение &lt;code class=&quot;highlighter-rouge&quot;&gt;InvokeClassMethod&lt;/code&gt; является просто кодом состояния, и для простого возврата скалярного значения из функции, ты собственноручно должен был сам позаботиться о соответствующем типе возвращаемого  аргумента при передаче длинного списка параметров).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Я слишком стар для таких многословных и долгих предварительных игр!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;В идеале мне хотелось получить короткий и простой метод передачи параметров в удаленную функцию, работающую на другой машине или в другой области.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Помните в Caché ObjectScript есть метод передачи переменного числа параметров через массив &lt;code class=&quot;highlighter-rouge&quot;&gt;args...&lt;/code&gt; в аргументах функции? Почему бы не поиспользовать такой механизм для скрытия всех этих грязных деталей низкоуровневого интерфейса, оставив нам просто название и список аргументов? И чтобы движок все сделал сам (догадавшись о типе передаваемых данных, например)?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// Пример прокси удаленного объекта посредством %Net.RemoteConnection
Class Sample.RemoteProxy Extends %RegisteredObject
{
Property RemoteConnection As %Net.RemoteConnection [Internal ];
Property LastStatus As %Status [InitialExpression = {$$$OK}];

Method %OnNew() As %Status
{
    set ..RemoteConnection = ##class(%Net.RemoteConnection).%New()

    return $$$OK
}

/// создать экземпляр указанного класса 
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%CreateInstance(className)
}

/// открыть экземпляр заданного класса по его %ID
Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%OpenObjectId(className, Id)
}

/// Соединение с системой посредством объекта конфигуратора 
/// { &quot;IP&quot;: IP, &quot;Namespace&quot; : Namespace, ... }
Method %Connect(Config As %Object) As Sample.RemoteProxy
{
    #dim sIP As %String = Config.IP
    #dim sNamespace As %String = Config.Namespace
    #dim sPort As %String = Config.Port
    #dim sUsername As %String = Config.Username
    #dim sPassword As %String = Config.Password
    #dim sClientIP As %String = Config.ClientIP
    #dim sClientPort As %String = Config.ClientPort
    
    if sIP = &quot;&quot; { set sIP = &quot;127.0.0.1&quot; }
    if sPort = &quot;&quot; { set sPort = ^%SYS(&quot;SSPort&quot;) }
    set ..LastStatus = ..RemoteConnection.Connect(sIP, sNamespace, sPort, 
                                                  sUsername, sPassword, 
                                                  sClientIP, sClientPort)
    
    return $this
}

ClassMethod ApparentlyClassName(CompoundName As %String, Output ClassName As %String, Output MethodName As %String) As %Boolean [Internal ]
{
    #dim returnValue As %Boolean = 0
    
    if $length(CompoundName, &quot;::&quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &quot;::&quot;, 1)
        set MethodName = $piece(CompoundName, &quot;::&quot;, 2, *)

        return 1
    } elseif $length(CompoundName, &quot;'&quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &quot;'&quot;, 1)
        set MethodName = $piece(CompoundName, &quot;'&quot;, 2, *)

        return 1
    }

    return 0
}

/// Динамическая диспетчеризация метода (класса) удаленного объекта
Method %DispatchMethod(methodName As %String, args...)
{
    #dim className as %String = &quot;&quot;
    
    if ..ApparentlyClassName(methodName, .className, .methodName) {
        return ..InvokeClassMethod(className, methodName, args...)
    }
    return 1
}

/// собственно вызов метода класса со всеми низкоуровневыми деталями
Method InvokeClassMethod(ClassName As %String, MethodName As %String, args...)
{
    #dim returnValue = &quot;&quot;
    #dim i as %Integer
    do ..RemoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = ..RemoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = ..RemoteConnection.InvokeClassMethod(ClassName, MethodName, .returnValue, $quit)
    return returnValue
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;Remote Proxy Draw&quot; src=&quot;/assets/remote-proxy/RemoteProxy.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;При проектировании данного интерфейса мы внесли несколько модных идиом, которые должны были послужить упрощению интерфейса взаимодействия, уменьшению размера кода, который надо писать, и, при возможности, увеличению стабильности интерфейса.&lt;/p&gt;

&lt;p&gt;Первое такое упрощение, которое мы пытались внести в интерфейс - это использование &lt;em&gt;объекта конфигуратора&lt;/em&gt; для передачи &lt;em&gt;именованных аргументов&lt;/em&gt; внутрь функции вместо их длинного списка. В Caché ObjectScript нет (ещё) встроенного способа передать &lt;a href=&quot;http://perldesignpatterns.com/?NamedArguments&quot;&gt;&lt;em&gt;именованные аргументы&lt;/em&gt;&lt;/a&gt;, и если, например, вам требуется передать только последние два аргумента из длинного списка параметров функции, то вам надо аккуратненько отсчитать запятые параметров которые вас не интересуют и передать в конце желаемое. Прямо скажем, крайне хрупкая конструкция.&lt;/p&gt;

&lt;p&gt;С другой стороны, с недавних пор в ObjectScript есть встроенная поддержка JSON объектов, которые можно создавать на лету, внутри выражения &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;. Мы можем по примеру Perl, попытаться переиспользовать такие динамически создаваемые объекты (в случае с Perl это был хеш) для передачи именованных аргументов функции. Динамический объект конфигуратор может содержать только те ключи-значения, которые нас интересуют.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:27:18:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})
 
DEVLATEST:16:27:39:MAPREDUCE&amp;gt;zw w
w=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.RemoteProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.RemoteProxy
| reference count: 2
+----------------- attribute values ------------------
|         LastStatus = 1
+----------------- swizzled references ---------------
|           i%Config = &quot;&quot;
|           r%Config = &quot;&quot;
| i%RemoteConnection = &quot;&quot;
| r%RemoteConnection = 2@%Net.RemoteConnection
+-----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Да, согласен, конструкция получается еще не настолько прозрачная, как получалась в Perl, т.к. все равно присутствуют дополнительные, обрамляющие объект фигурные скобки, но это уже путь в нужном направлении&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Вторая современная идиома, введенная в данном примере - каскадирование вызовов. Где это только было возможным мы возвращали из методов ссылку на текущий объект &lt;code class=&quot;highlighter-rouge&quot;&gt;%this&lt;/code&gt;, что позволяло вызывать несколько методов этого же класса в виде каскада.&lt;/p&gt;

&lt;p&gt;Меньше кода пишем - лучше спим.&lt;/p&gt;

&lt;h3 id=&quot;проблема-вызова-метода-класса&quot;&gt;Проблема вызова метода класса&lt;/h3&gt;

&lt;p&gt;Созданный нами объект оболочка, инкапсулирующий функциональность &lt;code class=&quot;highlighter-rouge&quot;&gt;Net.RemoteConnection&lt;/code&gt;, в текущем его состоянии не может сделать многого, чтобы мы хотели. Если нет места для хранения контекста создаваемого объекта… (Пока нет, Мы решим данную проблему позже, в другом классе) Единственное, что мы можем попытаться сделать сейчас, на текущем уровне абстракции и при текущем дизайне оболочки - это упростить способ вызова методов класса, вызываемых без ссылки на экземпляр объекта.&lt;/p&gt;

&lt;p&gt;Можем попытаться переопределить &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchClassMethod&lt;/code&gt;, но это в нашем случае сильно не поможет - мы хотим написать &lt;em&gt;обобщенный&lt;/em&gt; прокси класс, который бы работал для &lt;em&gt;любого&lt;/em&gt; удаленного класса. В случае простого отношения 1:1, когда некая специализированная оболочка на нашей стороне соответствует определенному классу на той стороне, такой подход с переопределением &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchClassMethod&lt;/code&gt; вполне сработает, но … не для обобщенного класса.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В общем случае, нам надо будет придумать что-то другое, но, желательно, по прежнему, простое, что работало бы с любым соединением и любым целевым классом.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Наше, достаточно элегантное решение данной проблемы мы приведем ниже, а пока отойдем в сторону и посмотрим, что в Caché ObjectScript может использоваться в качестве идентификатора метода или свойства. Не все знают (я, по крайней мере, узнал об этом пару лет назад) что имена идентификаторов в ObjectScript могут состоять не только из латинских букв и цифр, но и любых “символов алфавита” заданных текущей локалью (например, не только латинские буквы A-Za-z и арабские цифры 0-9, но и кириллические буквы А-Яа-я, &lt;em&gt;при установленной Русской локали&lt;/em&gt;). [&lt;a href=&quot;http://stackoverflow.com/questions/35452352/what-characters-are-usable-in-a-variable-name-in-objectscript-on-a-unicode-ins/35492721#35492721&quot;&gt;эта проблема вскользь обсуждалось в данной дискуссии на StackOverflow&lt;/a&gt;] Более того, если продолжать извращаться, то вы можете вставить в имя идентификатора любые эмодзи символы в качестве разделителя, &lt;em&gt;если вы создадите и активируете такую локаль&lt;/em&gt;, где эмодзи считались бы буквенными символами в текущем языке. В целом, всё же кажется, что любой, чувствительный к установленной локали трюк, не очень далеко полетит и не подходит как обобщенное решение, т.ч. давайте остановимся.&lt;/p&gt;

&lt;p&gt;… С другой стороны, идея использования некоего символа разделителя внутри имени метода (класса) кажется вполне разумной и многообещающей. Мы могли бы скрыть обработку разделителя внутри специальной реализации  &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchMethod&lt;/code&gt;, где бы мы отделяли название класса от имени метода, и соответственно передавали управление в нужный метод класс, скрывая все детали реализации.&lt;/p&gt;

&lt;p&gt;Так, пожалуй, и сделаем.&lt;/p&gt;

&lt;p&gt;Возвращаясь к синтаксису допустимых имен методов, еще менее известным фактом является факт, что вы можете записать в метод класса &lt;em&gt;вообще все что пожелаете&lt;/em&gt; если поместите такое имя внутри двойных кавычек “”. Скомбинировав “закавыченность” имени и специальный разделитель для имени класса я мог бы, например, вызывать метод класса &lt;code class=&quot;highlighter-rouge&quot;&gt;LogicalToDisplay&lt;/code&gt; из класса &lt;code class=&quot;highlighter-rouge&quot;&gt;Cinema.Duration&lt;/code&gt; пользуясь следующим, непривычным на первый взгляд, синтаксисом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:27:41:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})

DEVLATEST:16:51:39:MAPREDUCE&amp;gt;write w.&quot;Cinema.Duration::LogicalToDisplay&quot;(200)
3h20m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Выглядит немного странно, но крайне просто и компактно, не правда ли?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Специальная обработка имени и распознавание разделителей происходит в функции &lt;code class=&quot;highlighter-rouge&quot;&gt;ApparentlyClassName&lt;/code&gt;, где мы ищем специальные символы в качестве разделителя между &lt;em&gt;именем класса&lt;/em&gt; и названием &lt;em&gt;метода класса&lt;/em&gt; - такими разделителями были выбраны “::” (двойное двоеточие как в Си++) или “’” (одинарная кавычка как в Ada или первоначальном Perl-е).&lt;/p&gt;

&lt;p&gt;Заметим, что не стоит пытаться вывести что-либо на экран при таком удаленном методе класса - весь результат выдачи потеряется (проигнорируется), т.к. протокол cpp-binding не перехватывает выдачу на экран, и не возвращает её обратно, вызывающей стороне.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Протокол cpp-binding возвращает скалярные данные, а не побочные эффекты&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:51:47:MAPREDUCE&amp;gt;do w.&quot;Sample.Person::PrintPersons&quot;(1)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;прокси-удаленных-объектов&quot;&gt;Прокси удаленных объектов&lt;/h3&gt;

&lt;p&gt;Пока что мы не делали много полезного в коде &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy&lt;/code&gt;, приведенном выше: мы только создавали соединение, и пробрасывали вызовы методов класса.&lt;/p&gt;

&lt;p&gt;Если же вам надо создавать удаленные экземпляры классов или, паче чаяния, открывать объекты по их %ID, то вы можете воспользоваться сервисами другого нашего класса оболочки &lt;code class=&quot;highlighter-rouge&quot;&gt;%Sample.RemoteProxy.Object&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class Sample.RemoteProxy.Object Extends %RegisteredObject
{
/// хранит ссылку на открытый объект для последующих манипуляций
Property OpenedObject As %Binary;
Property Owner As Sample.RemoteProxy [ Internal ];
Property LastStatus As %Status [ InitialExpression = {$$$OK}, Internal ];

Method RemoteConnection() As %Net.RemoteConnection [ CodeMode = expression ]
{
..Owner.RemoteConnection
}

Method %OnNew(owner As Sample.RemoteProxy) As %Status
{
    set ..Owner = owner
    return $$$OK
}

/// создаём новый экземпляр определенного класса
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().CreateInstance(className, .pObject)
    set ..OpenedObject = &quot;&quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

/// создаём экземпляр определенного класса при заданном %ID
Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().OpenObjectId(className, Id, .pObject)
    set ..OpenedObject = &quot;&quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

/// исполнить метод открытого объекта с переданными аргументами
Method InvokeMethod(MethodName As %String, args...) [ Internal ]
{
    #dim returnValue = &quot;&quot;
    #dim i as %Integer
    #dim remoteConnection = ..RemoteConnection()
    do remoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = remoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = remoteConnection.InvokeInstanceMethod(..OpenedObject, MethodName, .returnValue, $quit)
    return returnValue
}

/// Динамическая диспетчеризация метода (класса) удаленного объекта
Method %DispatchMethod(methodName As %String, args...)
{
    //do ..LogArgs(methodName, args...)
    return ..InvokeMethod(methodName, args...)
}

/// Динамическая диспетчеризация чтения свойства удаленного объекта
Method %DispatchGetProperty(Property As %String)
{
    #dim value = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().GetProperty(..OpenedObject, Property, .value)
    return value
}

/// Динамическая диспетчеризация записи в свойство удаленного объекта
Method %DispatchSetProperty(Property, Value As %String) As %Status
{
   set ..LastStatus = ..RemoteConnection().SetProperty(..OpenedObject, Property, Value)
    return ..LastStatus
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;Remote Instance Method&quot; src=&quot;/assets/remote-proxy/RemoteInstanceMethod.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Если приглядеться, то можно распознать что в коде оболочки объекта по прежнему используется общий класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy&lt;/code&gt;, соединяющий нас с низкоуровневыми примитивами cpp-binding (в данном случае &lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt;). Каждый создаваемый экземпляр удаленного объекта инстанцирует экземпляр класса &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy.Object&lt;/code&gt;, внутри которого хранится ссылка на свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;..Owner&lt;/code&gt; типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy&lt;/code&gt; которое и используется для всяких соединительных целей. Данное свойство инициализируется в момент создания объекта из конструктора (смотри &lt;code class=&quot;highlighter-rouge&quot;&gt;%OnNew&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Мы также создали (относительно) удобный метод  &lt;code class=&quot;highlighter-rouge&quot;&gt;InvokeMethod&lt;/code&gt;, который может работать с любым количеством передаваемых аргументов, и который маршаллизирует данные через &lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt; в вызовы удаленных методов (ну, т.е. как и было в оригинальном примере с &lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt; он вызывает &lt;code class=&quot;highlighter-rouge&quot;&gt;ResetArguments&lt;/code&gt; перед началом заполнения списка аргументов и, в последующем, вызывает &lt;code class=&quot;highlighter-rouge&quot;&gt;AddArgument&lt;/code&gt; для каждого следующего аргумента, и заканчивая это все вызовом &lt;code class=&quot;highlighter-rouge&quot;&gt;%NetRemoteConnection::InvokeInstanceMethod&lt;/code&gt; для исполнения на “той стороне”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:19:23:54:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})

…

DEVLATEST:19:23:56:MAPREDUCE&amp;gt;set p = w.%OpenObjectId(&quot;Sample.Person&quot;,1)

DEVLATEST:19:24:05:MAPREDUCE&amp;gt;write p.Name
Quince,Maria B.
DEVLATEST:19:24:11:MAPREDUCE&amp;gt;write p.SSN
369-27-1697
DEVLATEST:19:24:17:MAPREDUCE&amp;gt;write p.Addition(1,2)
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном примере мы присоединяемся к локальной системе и её области “SAMPLES”, открываем экземпляр класса &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.Person&lt;/code&gt; по идентификатору 1, прочитываем его свойства (Name, SSN) и выполняем методы (Addition).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Таким образом, при правильном применении иерархии классов и механизмов языка, мы получаем простые и читабельные конструкции, вызывающие удаленный код, сохранив оригинальную семантику, но на порядок уменьшив количество требуемого кода.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;вместо-заключения&quot;&gt;Вместо заключения&lt;/h3&gt;

&lt;p&gt;Код, приведенный в наших примерах, не имеет еще продуктового качества (там нет правильной обработки ошибок, нет обработки разрывов соединения или удаления коллекции объектов, но, даже сейчас, такой маленький и простой набор классов позволит вам писать &lt;em&gt;читабельный и легко поддерживаемый&lt;/em&gt; код, оперирующий удаленными объектами на узлах кластера или в других областях конфигурации. Причем, значительно меньшими усилиями, и на порядок меньшим количеством строк.&lt;/p&gt;

&lt;p&gt;Чем мы и воспользуемся при написании кода MapReduce в следующих частях саги…&lt;/p&gt;

&lt;p&gt;Весь код, упомянутый здесь, доступен через &lt;a href=&quot;https://gist.github.com/tsafin/02bb6b5967cbdd1176618cb645445770&quot;&gt;gist&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">(Динамическая диспетчеризация спешит на помощь)</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature1.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">MapReduce из подручных материалов. Часть III – собираем все вместе</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-iii/" rel="alternate" type="text/html" title="MapReduce из подручных материалов. Часть III – собираем все вместе" /><published>2016-10-16T21:00:00+00:00</published><updated>2016-10-16T21:00:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-russian-part-iii</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-iii/">&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://fineartamerica.com/featured/mosaic-joan-pollak.html&quot;&gt;&lt;img src=&quot;https://habrastorage.org/files/6ff/2e3/a5d/6ff2e3a5d1404619883c068798441862.jpg&quot; alt=&quot;Mosaic by Joan Pollak&quot; align=&quot;left&quot; width=&quot;288&quot; height=&quot;240&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;../mapreduce-russian-part-i/&quot;&gt;В первой (достаточно капитанской) части этой серии&lt;/a&gt; мы рассказали про базовые концепции MapReduce почему это плохо, почему это неизбежно, и как с этим жить в других средах разработки (если вы не про Си++ или Java). Во &lt;a href=&quot;../mapreduce-russian-part-ii/&quot;&gt;второй части&lt;/a&gt; мы-таки начали рассказывать про базовые классы реализации MapReduce на Caché ObjectScript, введя абстрактные интерфейсы и их первичные реализации.
Сегодня пришел наш день! – мы покажем первый пример собранный в парадигме MapReduce, да, он будет странный и не самый эффективный, и совсем не распределенный, но вполне MapReduce.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;habracut /&gt;

&lt;h2 id=&quot;wordcount--простая-последовательная-реализация&quot;&gt;WordCount – простая, последовательная реализация&lt;/h2&gt;

&lt;p&gt;Вы уже, наверное, заметили что MapReduce – это про параллелизм и масштабирование. Но давайте признаемся сразу – алгоритм, какой бы элегантный и простой он ни был бы, очень сложно отлаживать сразу в его в параллельной инкарнации. Обычно, для простоты, мы стартуем с последовательной версии (в нашем случае это будет алгоритм wordcount) и затем подмешаем немного параллелизма.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://habrastorage.org/files/56e/cc4/174/56ecc41743d0499f8f52272190f98af3.png&quot; align=&quot;center&quot; /&gt;&lt;br /&gt;&lt;em&gt;Исполнение в среде MapReduce из статьи &lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/ru/archive/mapreduce-osdi04.pdf&quot;&gt;&quot;MapReduce: Simplified Data Processing on Large Clusters&quot;, OSDI-2004&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Напомним суть задачки wordcount: у нас есть набор текстов (например, все тома «Войны и мир») и вам нужно подсчитать количество слов во всем массиве. Этот простой пример использовался в оригинальной статье Google про MapReduce, потому каждый следующий, рассказывающий про MapReduce использует тот же самый пример. Считайте это &quot;HelloWorld!&quot; параллельного исполнения.&lt;/p&gt;

&lt;p&gt;Итак, последовательная реализация WordCount (но с применением MapReduce интерфейсов, введенных ранее) будет содержать все те же самые части, что и параллельная. И, например, mapper будет выглядеть примерно так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.WordCount.Mapper Extends (%RegisteredObject, MR.Base.Mapper)
{
/// read strings from MR.Base.Iterator and count words
Method Map(MapInput As MR.Base.Iterator, MapOutput As MR.Base.Emitter)
{
    while 'MapInput.IsAtEnd() {
        #dim line As %String = MapInput.GetNext()
        #dim pattern As %Regex.Matcher = ##class(%Regex.Matcher).%New(&quot;[^\s]+&quot;)
        set pattern.Text = line
        while pattern.Locate() {
            #dim word As %String = pattern.Group
            do MapOutput.Emit(word)
        }
    }
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Подпрограмма Map получает «входной поток» через параметр MapInput, и эмиттит данные в выходной MapOutput. Алгоритм тут очевиден – если во входном потоке еще остались данные (т.е. &lt;em&gt;НЕ&lt;/em&gt; &lt;em&gt;MapInput.IsAtEnd()&lt;/em&gt; ), то он прочтет следующую «строку» через MapInput.GetNext(), разобьет строку на слова при помощи %Regex.Matcher (смотри хорошую вводную статью про использование регулярных выражений в Caché на портале сообщества «&lt;a href=&quot;https://community.intersystems.com/post/using-regular-expressions-cach%C3%A9&quot;&gt;Using Regular Expressions in Caché&lt;/a&gt;») и каждое выделенное слово пересылается в выходной эмиттер.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;В классическом MapReduce интерфейсе мы всегда эмиттим «&lt;code class=&quot;highlighter-rouge&quot;&gt;ключ, значение&lt;/code&gt;», в данном случае мы сделали упрощение для случая «&lt;code class=&quot;highlighter-rouge&quot;&gt;ключ, 1&lt;/code&gt;», используя форму с 1 аргументом. Объяснение дано &lt;a href=&quot;https://habrahabr.ru/company/intersystems/blog/310196/&quot;&gt;в предыдущей части&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Процедура свертки (reducer) еще проще:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.WordCount.Adder Extends (%RegisteredObject, MR.Base.Reducer)
{
Method Reduce(ReduceInput As MR.Base.Iterator, ReduceOutput As MR.Base.Emitter)
{
    #dim result As %Numeric = 0
    while 'ReduceInput.IsAtEnd() {
        #dim value As %String = ReduceInput.GetNext() ; get &amp;lt;key,value&amp;gt; in $listbuild format
        #dim word As %String = $li(value,1)
        #dim count As %Integer = +$li(value,2)
        set result = result + count
    }
    do ReduceOutput.Emit(&quot;Count&quot;, result)
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Пока не встретили конца потока (&lt;code class=&quot;highlighter-rouge&quot;&gt;'ReduceInput.IsAtEnd()&lt;/code&gt;) тот продолжает потреблять данные из потока ReduceInput, и на каждой итерации из потока вынимается пара «ключ-значение» в бинарном формате списка &lt;code class=&quot;highlighter-rouge&quot;&gt;$listbuild&amp;lt;&amp;gt;&lt;/code&gt; (т.е. в виде &lt;code class=&quot;highlighter-rouge&quot;&gt;$lb(word,count)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Данная функция агрегирует число слов в переменную result и эмитит её итоговое значение н следующую стадию конвейера через поток ReduceOutput.&lt;/p&gt;

&lt;p&gt;Итак, мы показали mapper и reducer, пришла очередь показать главную, управляющую часть программы. Не рискуя сразу упереться в сложность параллелизма, мы заходим с последовательной версии алгоритма, хотя и использующую MapReduce идиому и интерфейсы. Да, в последовательном режиме, все эти отжимания с конвейером, не имеют большого смысла, но … упрощение необходимо в педагогических целях.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// Упрощенная, одно-поточная версия примера &quot;map-reduce&quot;.
/Class MR.Sample.WordCount.App Extends %RegisteredObject
{
ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new
    //kill ^mtemp.Map,^mtemp.Reduce

    #dim infraPipe As MR.Sample.GlobalPipe = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))
    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;
        // map
        #dim inputFile As MR.Input.FileLines = ##class(MR.Input.FileLines).%New(FileName)
        #dim mapper As MR.Sample.WordCount.Mapper = ##class(MR.Sample.WordCount.Mapper).%New()

        do mapper.Map(inputFile, infraPipe)

        // reduce
        #dim outPipe As MR.Base.Emitter = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
        #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()
        while 'infraPipe.IsAtEnd() {
            do reducer.Reduce(infraPipe, outPipe)
        }
        do outPipe.Dump()
    }
    quit

DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt
    ;;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Попытаемся объяснить этот код строчка за строчкой:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;В обычном случае мы такого не рекомендуем делать, но в данном случае это необходимо: мы выключаем процедурные блоки &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=ROBJ_class_procedureblock&quot;&gt;ProcedureBlock = 0&lt;/a&gt; и возвращаемся к старой семантике с ручным управлением содержимым таблицы символов с локальными переменными. Нам это нужно для встраивания блока DATA содержащего входные данные (в данном случае пути до входных файлов), к которым мы будем обращаться через функцию &lt;code class=&quot;highlighter-rouge&quot;&gt;$TEXT&lt;/code&gt;. В данном случае мы используем 4 тома «Войны и мира» Льва Толстого;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Мы будем использовать для промежуточного хранения данных между стадиями конвейера глобалы вида &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp.Map($J)&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp.Reduce($J)&lt;/code&gt;. По волшебному стечению обстоятельств, глобалы вида &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp*&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;^CacheTemp*&lt;/code&gt; автоматически отображаются во временную базу &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCPF_Namespace_n&quot;&gt;CACHETEMP&lt;/a&gt; не будут журналироваться и будут поддерживаться в памяти (насколько это возможно). Будем рассматривать их как &quot;in-memory&quot; глобалы.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Промежуточный канал intraPipe является экземпляром &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.GlobalPipe&lt;/code&gt;, который в нашем случае – просто синоним класса &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.EmitterSorted&lt;/code&gt;, и как мы описали в &lt;a href=&quot;https://habrahabr.ru/company/intersystems/blog/310196/&quot;&gt;предыдущей части&lt;/a&gt; автоматически очищается в конце работы программы.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.GlobalPipe Extends (%RegisteredObject, MR.Emitter.Sorted) { }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Мы проходим по строкам &lt;code class=&quot;highlighter-rouge&quot;&gt;$TEXT(DATA+i)&lt;/code&gt;, вытаскиваем 3ий аргумент строки, разделенной &quot;;&quot;. Если результат непустой – то мы используем это значение как имя входного файла.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Входной итератор «маппера» (объекта отображения) будем экземпляром MR.Input.FileLines, который мы еще не показывали…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Input.FileLines Extends (%RegisteredObject, MR.Base.Iterator)
{
Property File As %Stream.FileCharacter;
Method %OnNew(FileName As %String) As %Status
{
    set ..File = ##class(%Stream.FileCharacter).%New()
    #dim sc As %Status = ..File.LinkToFile(FileName)
    quit sc
}
Method GetNext() As %String
{
    if $isobject(..File) &amp;amp;&amp;amp; '..File.AtEnd {
        quit ..File.ReadLine()
    }
    quit &quot;&quot;
}
Method IsAtEnd() As %Boolean
{
    quit '$isobject(..File) || ..File.AtEnd
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вернемся обратно к приложению &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.WordCount.App&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Объект «маппер» будет экземпляром уже известного &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.WordCount.Mapper&lt;/code&gt; (см. выше). Экземпляр создается отдельно для каждого обрабатываемого файла.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;В цикле мы последовательно вызываем функцию Map маппера, передавая экземпляр входного потока, работающего с открытым файлом. В этом конкретном случае стадия отображения линеаризуется в последовательном цикле. Что не очень типично для MapReduce но нужно в качестве упрощенного упражнения.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;На стадии свертки мы получаем: выходной объект эмиттера (&lt;code class=&quot;highlighter-rouge&quot;&gt;outPipe&lt;/code&gt;) как экземпляр &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Emitter.Sorted&lt;/code&gt;, который указывает на &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp.Reduce($J)&lt;/code&gt;. Напоминаю, что спецификой &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Emitter.Sorted&lt;/code&gt; будет использование реализации B*-Tree в движке Caché для различных оптимизаций. Ключи-значения хранятся в персистентном хранилище естественным образом отсортированными, и потому становятся возможными реализации свертки с автоинкрементом выходных значений.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Объект свертки является экземпляром &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.WordCount.Adder&lt;/code&gt; описанного выше.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Для каждого открытого файла, и на той же итерации цикла, мы вызываем &lt;code class=&quot;highlighter-rouge&quot;&gt;reducer.Reduce&lt;/code&gt;, передавая туда как промежуточный поток &lt;code class=&quot;highlighter-rouge&quot;&gt;infraPipe&lt;/code&gt;, так и выходной поток.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вроде бы все части в сборе – давайте посмотрим как это все работает.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:MAPREDUCE:23:53:27:.000203&amp;gt;do ##class(MR.Sample.WordCount.App).MapReduce()
^mtemp.Reduce(3276,&quot;Count&quot;)=114830
^mtemp.Reduce(3276,&quot;Count&quot;)=123232
^mtemp.Reduce(3276,&quot;Count&quot;)=130276
^mtemp.Reduce(3276,&quot;Count&quot;)=109344
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы видим вычисленное число слов в каждом томе книги, которое выводится в конце каждой итерации цикла. Это все хорошо, но остаются 2 вопроса, на которые мы не получили ответ:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Какое общее число слов во всех томах?&lt;/li&gt;
  &lt;li&gt;И уверены ли мы, что выданные числа корректны? Что, кстати, не начальном этапе написания программ является более важным.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Начнем с ответа на второй вопрос, с верификации результата – проверить это просто, запустив Linux/Unix/Cygwin утилиту &lt;code class=&quot;highlighter-rouge&quot;&gt;wc&lt;/code&gt; на тех же самих данных:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Timur@TimurYoga2P /cygdrive/c/Users/Timur/Documents/mapreduce/data
$ wc -w war*.txt
 114830 war_and_peace_vol1.txt
 123232 war_and_peace_vol2.txt
 130276 war_and_peace_vol3.txt
 109344 war_and_peace_vol4.txt
 477682 total
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Видим, что вычисленное число слов для каждого тома было правильным, т.ч. перейдем к вычислению финального, агрегатного значения.&lt;/p&gt;

&lt;h3 id=&quot;измененный-вариант--с-подсчетом-общей-суммы&quot;&gt;Измененный вариант – с подсчетом общей суммы&lt;/h3&gt;

&lt;p&gt;Для подсчета финальной суммы нам надо внести 2 простых изменений в код программы показанный выше:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Нужно применить метод рефакторинга &lt;a href=&quot;http://refactoring.com/catalog/extractMethod.html&quot;&gt;&quot;Extract Method&quot;&lt;/a&gt; на части кода маппера. В дальнейшем нам эта часть кода понадобится отдельно, в виде &lt;em&gt;метода класса,&lt;/em&gt; что, в итоге, упростит дальнейшие модификации с параллелизацией или даже удаленным исполнением кода.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Также, нам нужно вынести инстанцирование объектов reducer и вызов его функции Reduce из цикла вовне. Цель такой модификации – не удалять промежуточный канал с данными в конце каждой итерации, и продолжать аккумулировать данные между итерациями, для показа общей суммы  после цикла. Агрегатная сумма будет подсчитываться автоматически, т.к. мы применим автоинкрементный вариант.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Во всех остальных случаях эти два приводимых примера ведут себя идентично – оба используют временные глобалы &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp.Map($J)&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;^mtemp.Reduce($J)&lt;/code&gt; в качестве промежуточного и финального хранилища на стадиях отображения и свертки.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.WordCount.AppSum Extends %RegisteredObject
{
ClassMethod Map(FileName As %String, infraPipe As MR.Sample.GlobalPipe)
{
    #dim inputFile As MR.Input.FileLines      = ##class(MR.Input.FileLines).%New(FileName)
    #dim mapper As MR.Sample.WordCount.Mapper = ##class(MR.Sample.WordCount.Mapper).%New()

    do mapper.Map(inputFile, infraPipe)
}
ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new

    #dim infraPipe As MR.Sample.GlobalPipe    = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))
    #dim outPipe As MR.Base.Emitter           = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
    #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()

    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;

        do ..Map(fileName, infraPipe)
        //do infraPipe.Dump()

    }
    while 'infraPipe.IsAtEnd() {
        do reducer.Reduce(infraPipe, outPipe)
    }
    do outPipe.Dump()

    quit
DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt
    ;;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;параллельная-реализация&quot;&gt;Параллельная реализация&lt;/h3&gt;

&lt;p&gt;Давайте сразу признаемся себе – такие отжимания с MapReduce интерфейсами при создании простого алгоритма для подсчета слов не были самым простым, очевидным и естественным подходом при разработке такой тривиальной программы. Но потенциальные «плюшки», которые мы можем получить здесь все же перевешивают все начальные проблемы и дополнительную боль. При разумном планировании параллелизма и с применением соответствующих алгоритмов, мы можем получить масштабирование, которое сложно получить на последовательных алгоритмах. Например, в данном случае, на простом low-power Haswell ULT ноутбуке, на котором пишется данная статья, последовательный алгоритм отрабатывал за 4.5 секунды, тогда как параллельная версия завершалась за 2.6 секунды.&lt;/p&gt;

&lt;p&gt;Разница не такая драматическая, но достаточно существенная, особенно принимая во внимание малый входной набор и всего два ядра на ноутбуке.&lt;/p&gt;

&lt;p&gt;Вернемся к коду – на предыдущем этапе мы, на стадии отображения, выделили функцию в отдельный метод класса, получающий два аргумента (имя входного файла и имя выходного глобала). Мы выделили данный код в отдельную функция с одной простой целью – облегчить создание параллельной версии. Такая параллельная версия будет использовать механизм worker в Caché ObjectScript &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr&quot;&gt;($system.WorkMgr)&lt;/a&gt; Ниже мы преобразуем последовательную версию, созданную на предыдущем шаге, в параллельную посредством вызова программ обработчиков (worker), запускаемых с выделенным методом класса.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// Версия #2 Более продвинутая, использующая несколько воркеров
Class MR.Sample.WordCount.AppWorkers Extends %RegisteredObject
{
ClassMethod Map(FileName As %String, InfraPipeName As %String) As %Status
{
    #dim inputFile As MR.Input.FileLines        = ##class(MR.Input.FileLines).%New(FileName)
    #dim mapper As MR.Sample.WordCount.Mapper   = ##class(MR.Sample.WordCount.Mapper).%New()
    #dim infraPipe As MR.Sample.GlobalPipeClone = ##class(MR.Sample.GlobalPipeClone).%New(InfraPipeName)

    do mapper.Map(inputFile, infraPipe)

    quit $$$OK
}
ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new
    #dim infraPipe As MR.Sample.GlobalPipe = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))
    #dim outPipe As MR.Base.Emitter = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
    #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()

    #dim sc As %Status = $$$OK
    // do $system.WorkMgr.StopWorkers()
    #dim queue As %SYSTEM.WorkMgr = $system.WorkMgr.Initialize(&quot;/multicompile=1&quot;, .sc) 
    quit:$$$ISERR(sc)

    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;

        //do ..Map(fileName, infraPipe)
        set sc = queue.Queue(&quot;##class(MR.Sample.WordCount.AppWorkers).Map&quot;, fileName, infraPipe.GlobalName)
        quit:$$$ISERR(sc)
    }
    set sc = queue.WaitForComplete() quit:$$$ISERR(sc)

    while 'infraPipe.IsAtEnd() {
        do reducer.Reduce(infraPipe, outPipe)
    }
    do outPipe.Dump()

    quit
DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt
    ;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ранее пример назывался AppSum, Новый пример нзывается AppWorkers, и разница между ними очень маленькая, но важная – мы вызываем процедуру отображения в отдельном треде (процессе) обработчике посредством &lt;code class=&quot;highlighter-rouge&quot;&gt;$system.WorkMgr.Queue&lt;/code&gt; API. Это API может вызывать простую подпрограмму, или метод класса, но (по естественным причнима) не может вызывать методы объекта, т.к. не предусмотрен механизм передачи объекта во внешний процесс.&lt;/p&gt;

&lt;p&gt;При вызове параллельного обработчика через это API накладываются дополнительные ограничения и на типы передаваемых значений:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Мы не можем передавать значения по ссылке и, как следствие, не можем возвращать измененные значения таких аргументов;&lt;/li&gt;
  &lt;li&gt;Более того, мы можем передавать только простые скалярные значения (числа и строки), но не объекты.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Но тут, дорогой Хьюстон, у нас проблема&lt;/em&gt;. В предыдущем примере метод &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.WordCount.AppSum::Map&lt;/code&gt; получал в качестве 2го аргумента экземпляр класса &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.Sample.GlobalPipe&lt;/code&gt;. Но мы не можем передавать объекты между процессами (а worker – это отдельный процесс из пула процессов). И в данном случае, нам нужно придумать простую схему «сериализации»/«десериализации» объекта в литеральные значения, для того чтобы это можно было передать в параллельный обработчик через &lt;code class=&quot;highlighter-rouge&quot;&gt;$system.WorkMgr.Queue&lt;/code&gt; API.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;В случае с &lt;code class=&quot;highlighter-rouge&quot;&gt;GlobalPipe&lt;/code&gt; “простой метод сериализации” – действительно получается простым. Если передать имя промежуточного глобала то этого достаточно для адекватной передачи состояния нашего  объекта. Вот почему вторым аргументом метода &lt;code class=&quot;highlighter-rouge&quot;&gt;MR.SampleWordCount.AppWorkers::Map&lt;/code&gt; становится строка с именем глобала, а не объект.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Рекомендуем прочитать документацию по параллельным обработчикам &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr&quot;&gt;здесь&lt;/a&gt;, но на будущее запомните, что если вы хотите использовать параллельные обработчики (в максимальном количестве, которое позволительно при вашем железе и лицензии) то при инициализации обработчиков вам стоит передать параметр со странным именем &quot;&lt;code class=&quot;highlighter-rouge&quot;&gt;/multicompile=1&lt;/code&gt;&quot;. [Странное имя объясняется тем, что эта функциональность была добавлена для параллельной компиляции в трансляторе классов Caché ObjectScript. С тех пор этот модификатор стал использоваться и вне кода транслятора.]&lt;/p&gt;

&lt;p&gt;Как только мы запланировали исполнение метода через &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr#Queue&quot;&gt;$system.WorkMgr.Queue&lt;/a&gt;, мы можем запустить все запланированные подпрограммы и дождаться их завершения через &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr#Queue&quot;&gt;$system.WorkMgr.WaitForComplete&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Все параллельные обработчики будут использовать один и тот же промежуточный глобал &lt;code class=&quot;highlighter-rouge&quot;&gt;infraPipe&lt;/code&gt; для передачи данных между стадиями конвейера, но коллизий с данными не стоит ожидать, т.к. нижележащий движок данных отработает их корректно. Напомним, что архитектура Caché изначально &lt;em&gt;многопроцессная&lt;/em&gt;, с множеством масштабируемых механизмов синхронизации между процессами, работающими с одними и теми же данными. Дополнительно заметим, что наш упрощенный пример с вычислением общего числа слов во всех томах исполняет свертку (reducer) в одном потоке, что также упрощает код и избавляет нас от некоторой головной боли.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Таким образом, на текущий момент мы успели рассказать об общих терминах алгоритмов MapReduce, создали базовые интерфейсы MapReduce при реализации их в контексте среды Caché ObjectScript, и создали в этой же среде простой пример с подсчетом слов. В следующей статье мы покажем другие используемые в нашей реализации идиомы, используя второй классический пример из WikiPedia – AgeAverage. Всё только начинается!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">В первой (достаточно капитанской) части этой серии мы рассказали про базовые концепции MapReduce почему это плохо, почему это неизбежно, и как с этим жить в других средах разработки (если вы не про Си++ или Java). Во второй части мы-таки начали рассказывать про базовые классы реализации MapReduce на Caché ObjectScript, введя абстрактные интерфейсы и их первичные реализации. Сегодня пришел наш день! – мы покажем первый пример собранный в парадигме MapReduce, да, он будет странный и не самый эффективный, и совсем не распределенный, но вполне MapReduce.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature5.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-ii/" rel="alternate" type="text/html" title="Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации" /><published>2016-10-04T10:24:00+00:00</published><updated>2016-10-04T10:24:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-russian-part-ii</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-ii/">&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://fineartamerica.com/featured/take-it-like-a-man-joan-pollak.html&quot;&gt;&lt;img src=&quot;https://habrastorage.org/files/e4c/cac/f03/e4ccacf0316840bca92ee668bfdb1f95.jpg&quot; align=&quot;left&quot; width=&quot;288&quot; height=&quot;240&quot; alt=&quot;Take it like a man by Joan Pollak&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;../mapreduce-russian-part-i/&quot;&gt;В предыдущей части серии&lt;/a&gt; мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Напомним первоначальный посыл нашего мини-проекта: вы всё еще планируем реализовать MapReduce алгоритм используя те подручные средства, что есть в Caché ObjectScript. При создании интерфейсов, мы попытаемся придерживаться того API, что мы описали в предыдущей статье про оригинальную реализацию Google MapReduce, любые девиации будут озвучены соответствующе.&lt;/p&gt;
&lt;habracut /&gt;

&lt;p&gt;Начнем с реализации абстрактных интерфейсов Mapper и Reducer.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Class MR.Base.Mapper 
{
Method Map(MapInput As MR.Base.Iterator, MapOutput As MR.Base.Emitter) [ Abstract ] { }
}

Class MR.Base.Reducer
{
Method Reduce(ReduceInput As MR.Base.Iterator, ReduceOutput As MR.Base.Emitter) [ Abstract ] { }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Изначально, как и в канонической реализации, мы сделали 2 отдельных интерфейса MapInput и ReduceInput. Но сразу стало очевидным, что они служат одной и той же цели, и предоставляют одни и те же методы – их цель пройтись по потоку данных до конца, т.ч. они оба являются итераторами. Потому, в итоге, редуцируем их в общий интерфейс MR.Base.Iterator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Class MR.Base.Iterator
{

Method GetNext() As %String [Abstract ] { }

Method IsAtEnd() As %Boolean [Abstract ] { }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;использование-глобалов-в-качестве-каналов-связи&quot;&gt;Использование глобалов в качестве каналов связи&lt;/h2&gt;

&lt;p&gt;Оригинальная реализация Google MapReduce использовала файловую систему Google GFS как транспорт между узлами и стадиями алгоритма. В Caché есть свой механизм распространения (когерентных) данных между узлами (если не пользоваться голым TCP/UDP) – это протокол ECP (&lt;a href=&quot;http://docs.intersystems.com/documentation/cache/latest/pdfs/GDDM.pdf&quot;&gt;Enterprise Caсhe Protocol&lt;/a&gt;). Обычно он используется серверами приложений для получения данных от удаленных серверов баз данных. Но ничего не останавливает нас от построения на базе таких peer-to-peer соединений ECP некоей виртуальной управляющей шины, куда мы будем складывать данные в виде пар &amp;lt;ключ,значение&amp;gt; или похожие данные. Эти данные будут будут пересылаться между акторами, участвующими в конвейерах алгоритма (т.е. emit, посылаемый объектом Mapper, будет писаться в шину ECP и читаться объектом Reducer). Если акторы будут работать в рамках одного узла, то они, например могут использовать быстрые глобалы, отображенные в CACHETEMP, или обычные глобалы, если реализуемый алгоритм многостадийный и нужна надежность и журналирование.&lt;/p&gt;

&lt;p&gt;В любом случае, будь то локальные (для конфигурации на одном узле) глобалы, или глобалы удаленного узла, подключенного через ECP, глобалы являются удобным и хорошо зарекомендовавшим себя транспортом для передачи данных между узлами кластера Caché, в данном случае, между вовлеченными в MapReduce функциями и классами.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Посему, естественным решением, позволяющим упростить нашу систему будет использование в среде Caché для передачи данных между узлами кластера протокола ECP вместо файловых систем GFS или HDFS. Функциональные характеристики ECP позволят сделать и другие упрощения (но об этом несколько позже).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;эмиттеры-и-черная-магия&quot;&gt;Эмиттеры и черная магия&lt;/h2&gt;

&lt;p&gt;Как мы уже рассказывали &lt;a href=&quot;https://habrahabr.ru/company/intersystems/blog/310180/&quot;&gt;в предыдущей серии&lt;/a&gt;, с момента когда данные уходят от объекта Mapper, и до момента как они поступают на вход Reducer, в классической реализации на мастере проходит тяжелая операция перемешения и сортировки.&lt;/p&gt;

&lt;p&gt;В окружении, использующем глобалы к качестве транспорта, в MUMPS/Caché ObjectScript среде, мы можем полностью избежать дополнительных расходов на такую сортировку, т.к. агрегация и сортировка будут сделаны нижележащим btree* хранилищем.&lt;/p&gt;

&lt;p&gt;Имея такие требования к дизайну, создадим базовый интерфейс эмиттера:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Class MR.Base.Emitter Extends MR.Base.Iterator
{

/// emit $listbuild(key,value(s))
Method Emit(EmitList... As %String) [Abstract ] { }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эмиттер должен быть похож на интерфейс входного итератора, показанного выше (потому мы и пронаследовались от MR.Base.Iterator), но в дополнение к интерфейсу прохода по данным, эмиттер должен уметь еще и посылать данные в своё промежуточное хранилище (т.е. добавляем функцию Emit).&lt;/p&gt;

&lt;p&gt;Первоначально, наша функция Emit была очень похожа на классическую реализацию и принимала только 2 аргумента как пару &amp;lt;ключ,значение&amp;gt;, но потом мы натолкнулись на (редкую) необходимость передавать что-то более многомерное, длиннее чем пара значений (например, кортеж любой арности), потому, в настоящий момент, Emit стал функцией принимающей переменное число аргументов.&lt;/p&gt;

&lt;p&gt;Заметим, что в большинстве случаев, на практике, сюда будет поступать только пара аргументов &amp;lt;ключ,значение&amp;gt; как мы и видели в классической реализации.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Это всё ещё абстрактный интерфейс, больше мяса будет добавлено очень скоро.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Если бы нам, при обработке, надо было сохранять порядок поступивших элементов, то мы бы использовали реализацию ниже:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/// Emitter which maintains the order of (key,value(s))
Class MR.Emitter.Ordered Extends (%RegisteredObject, MR.Base.Emitter)
{
   /// global name serving as data channel
Property GlobalName As %String;
Method %OnNew(initval As %String) As %Status
{
    $$$ThrowOnError($length(initval)&amp;gt;0)
    set ..GlobalName = initval 
    quit $$$OK
}

Parameter AUTOCLEANUP = 1;
Method %OnClose() As %Status
{
    if ..#AUTOCLEANUP {
        if $data(@i%GlobalName) {
            kill @i%GlobalName
        }
    }
    Quit $$$OK
}
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Заметим на полях, что в Caché глобалы – в общем-то, глобальны :) , и не будут очищены автоматически по завершении процессов их создавших. В отличие, например, от &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GCOS_variables#GCOS_variables_procprivglbls&quot;&gt;PPG (process-private globals)&lt;/a&gt;. Но иногда все же хочется, чтобы наши промежуточные каналы, созданные для взаимодействия между стадиями конвейера MapReduce удалялись по завершении подпрограммы их создавшей. Поэтому и был добавлен режим “автоочистки” (параметр класса #AUTOCLEANUP) при котором глобал, имя которого хранится в свойстве GlobalName, будет удален при закрытии объекта (в момент вызова %OnClose).&lt;/p&gt;

&lt;p&gt;Обратите внимание, что мы форсируем один обязательный параметр в метода %New (в %OnNew генерируем $$$ThrowOnError если имя в Initval не определено). Конструктор класса ожидает получить название глобала с которым он будет работать в качестве транспорта данных.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Class MR.Emitter.Ordered Extends MR.Base.Emitter
{
/// ... 
Method IsAtEnd() As %Boolean
{
    quit ($data(@i%GlobalName)\10)=0
}

/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim list As %String = &quot;&quot;
    for i=1:1:$get(EmitList) {
        set $li(list,i) = $get(EmitList(i))
    }
    #dim name As %String = ..GlobalName
    set @name@($seq(@name)) = list
}

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim value As %String
    #dim index As %String = $order(@i%GlobalName@(&quot;&quot;), 1, value)

    if index '= &quot;&quot; {
        kill @i%GlobalName@(index)
        quit value
    } else {
        kill @i%GlobalName
        quit &quot;&quot;
    }
}

Method Dump()
{
    zwrite @i%GlobalName
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Надеемся, вы еще помните, что наш Emitter является наследником итератора Iterator? Посему ему нужно реализовать пару функций итератора – IsAtEnd и GetNext.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IsAtEnd – простой: если наш служебный глобал не содержит данных (т.е. &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RVBS_fdata&quot;&gt;$data(..GlobalName)&lt;/a&gt; не возвращает 10 или 11, что означает что там в поддереве есть еще узлы с данными), то мы достигли конца потока данных;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Emit создает узел с данными в конце текущего списка. Оформляя пару (или кортеж, при арности больше 2х) как элемент &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RSQL_d_listbuild&quot;&gt;$(listbuild(…))&lt;/a&gt; [listbuild].&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как известно, и как хорошо написал &lt;a href=&quot;https://habrahabr.ru/company/intersystems/blog/263793/&quot;&gt;Саша Коблов, $SEQUENCE&lt;/a&gt; может быть использована почти во всех местах, где использовался &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fincrement&quot;&gt;$INCREMENT&lt;/a&gt;, обеспечивая при этом лучшие скорости при работе в многопроцессорном или многосерверном режиме (через ECP). В силу меньшего количества коллизий при обращении к одном узлу глобала. Потому в коде выше мы используем &lt;em&gt;$sequence&lt;/em&gt; для выделения индекса следующего элемента упорядоченного списка.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;На другой стороне алгоритма, в получателе GetNext() вытаскивает элементы из коллекции посредством простого &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_forder&quot;&gt;$ORDER(@i%GlobalName(“”))&lt;/a&gt;. Элемент, с полученным индексом будет удален из списка после обработки.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Обращаем внимание, что данный вариант удаления элемента из списка/глобала &lt;a href=&quot;https://community.intersystems.com/post/cach%C3%A9-mapreduce-basic-interfaces-mapreduce-implementation-part-ii#comments&quot;&gt;не очень совместим с параллельным режимом&lt;/a&gt;, и нужно было бы добавить блокировки или сменить структуру данных. Но т.к. на ближайшие серии у нас будет только один Reducer, на всё множество Mapper ов, то мы отложим решение данной проблемы на будущее, когда приступим к много-серверной реализации.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Заметим, что структура данных, реализованная MR.Emitter.Ordered по сути реализуют классическую коллекцию FIFO (&quot;FirstIn – FirstOut&quot;). Мы помещаем новый элемент в конец списка и вытаскиваем из головы списка.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;специальный-случай-эмиттер-с-автоагрегацией&quot;&gt;Специальный случай: эмиттер с автоагрегацией&lt;/h3&gt;

&lt;p&gt;Если вы посмотрите на те данные, что мы посылаем в между стадиями конвейера в примере word-count (ок, не сейчас, а когда мы вам покажем такую реализацию) то вы быстро осознаете, что:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;На самом деле нам не интересен порядок, в котором мы “эмиттим”  пары &amp;lt;ключ, значение&amp;gt;. Более того, нижележащее хранилище btree* всегда держит список ключей отсортированным для быстрого поиска, избавляя нас от необходимости сортировки на мастере, как произошло бы в классической реализации;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;И в наших случаях, когда мы пишем пару &amp;lt;key,1&amp;gt; на стороне Mapper, мы предполагаем в Reducer их простую агрегацию в сумму единиц. Т.е. в случае Caché ObjectScript мы полагались бы на использование &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fincrement&quot;&gt;$INCREMENT&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Так зачем посылать такой большой трафик ненужных данных, если мы можем их агрегировать еще в момент посылки?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Именно так и работает MR.Emitter.Sorted, который является наследником MR.Emitter.Ordered (показанного выше):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/// Emitter which sorts by keys all emitted pairs or tuples (key, value(s))
Class MR.Emitter.Sorted Extends MR.Emitter.Ordered
{
Property AutoIncrement As %Boolean [ InitialExpression = 1 ];
/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim name As %String = ..GlobalName
    #dim key As %String
    #dim value As %String 

    if $get(EmitList)=1 {
        // special case - only key name given, no value
        set key = $get(EmitList(1))
        quit:key=&quot;&quot;
        if ..AutoIncrement {
            #dim dummyX As %Integer = $increment(@name@(key)) ; $seq is non-deterministic
        } else {
            set @name@(key) = 1
        }
    } else {
        set value = $get(EmitList(EmitList))
        set EmitList = EmitList - 1
        for i=1:1:$get(EmitList) {
            #dim index As %String = $get(EmitList(i))
            quit:index=&quot;&quot;
            set name = $name(@name@(index))
        }
        if ..AutoIncrement {
            #dim dummyY As %Integer = $increment(@name,value)
        } else {
            set @name = value
        }
    }
}
/// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Для самого простого случая, выдачи пары &amp;lt;key,1&amp;gt; или, когда значение опущено, и имеет один ключ &amp;lt;key&amp;gt; мы реализовали локальную оптимизацию, когда в режиме автоинкремента (AutoIncrement = 1) мы при вызове сразу инкрементируем соответствующий счетчик для ключа. Если же не включен автоинкремент, то мы просто (пере)определяем узел ключа в 1, фиксируя факт передачи ключа.&lt;/p&gt;

&lt;p&gt;Для более общего случая, с двумя элементами, пары ключ-значение &amp;lt;key,value&amp;gt; или даже с большим количеством элементов &amp;lt;key,key2,key3,…keyn,value&amp;gt; (кортеж любой арности) у нас опять же реализовано 2 режима работы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;при &lt;em&gt;автоинкременте&lt;/em&gt; мы сразу суммируем значение соответствующего узла, адресуемого ключом(ключами) с переданным значением;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;и &lt;em&gt;без автоинкремента&lt;/em&gt; – мы присваиваем соответствующему узлу, адресуемому данным списком ключей, переданное значение value.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Обращаем внимание, что кортеж мы передаем посредством массива, аккумулирующего переменное количество аргументов. Все элементы этого массива кроме последнего, пойдут как адреса &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_structure#GGBL_structure_nodes_and_subscripts&quot;&gt;подындексов&lt;/a&gt;. Последний элемент кортежа будет считаться значением.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Такое необычное расширение пары «ключ-значение» в кортежи любой мощности, по нашим сведениям, является нетипичным или может быть уникальным. Нам не надо работать со строгим key-value хранилищем или bigtable хранилищем, и мы с легкостью можем работать с многомерными ключами в передаваемых элементах (“потому что можем”), что может сильно облегчить некоторые реализации алгоритмов, требующих дополнительной размерности данных, что сильно улучшает читабельность кода и упрощает понимание. В теории…&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Заметим, что мы не переопределили IsAtEnd и он пронаследовал реализацию из MR.Emitter.Ordered, таким образом он по-прежнему будет возвращать ненулевое значение по окончании данных в подузлах промежуточного хранилища.&lt;/p&gt;

&lt;p&gt;Но GetNext нам надо переопределить, т.к. мы больше не пытаемся запомнить порядок посланных данных и формат его внутреннего хранилища поменялся:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Class MR.Emitter.Sorted Extends MR.Emitter.Ordered 
{
/// ...

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim name As %String = ..GlobalName
    #dim value As %String
    #dim ref As %String = $query(@name,1,value)
    if ref'=&quot;&quot; {
        zkill @ref
        #dim i As %Integer
        #dim refLen As %Integer = $qlength(ref)
        #dim baseLen As %Integer = $qlength(name)
        #dim listbuild = &quot;&quot;
        for i=baseLen+1:1:refLen {
            set $li(listbuild,i-baseLen)=$qs(ref,i)
        }
        set $li(listbuild,*+1)=value

        quit listbuild
    }

    quit &quot;&quot;
}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;На выходе из GetNext() мы ожидаем &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_flistbuild&quot;&gt;$LISTBUILD&amp;lt;&amp;gt;&lt;/a&gt; список, но внутри хранилища данные пар/кортежей разбросаны по узлам иерархического хранилища. Функция &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fquery&quot;&gt;$QUERY&lt;/a&gt; позволяет обойти узлы с данными (значениями пар/кортежей) в массиве для последующей их перепаковки в $LISTBUILD формат, индексы из массива последовательно добавляются следующим элементом списка (посредством присваивания элементу через функцию &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_flist&quot;&gt;$LIST&lt;/a&gt;. Само же значение узла хранилища (значение в паре «ключ-значение» или последний элемент кортежа) будет добавлено в конец сформированного списка через ту же функцию $LIST(listbuild,*+1). В данном случае *+1 как раз и обозначат номер элемента списка, следующий за текущим концом.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;На этом неожиданном месте мы прервем наш рассказ про MapReduce в Caché. Во второй части данного повествования мы показали базовые интерфейсы инфраструктуры, которые будут использованы в дальнейшем при реализации конкретных примеров. Уже в следующей серии мы соберем это всё воедино и реализуем классический пример WordCount, но уже на ObjectScript. Не уходите далеко!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">В предыдущей части серии мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature6.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Какая-такая Data? или Еще раз про MapReduce</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-i/" rel="alternate" type="text/html" title="Какая-такая Data? или Еще раз про MapReduce" /><published>2016-09-26T14:07:00+00:00</published><updated>2016-09-26T14:07:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-russian-part-i</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-russian-part-i/">&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://habrahabr.ru/company/intersystems/blog/310180/&quot;&gt;&lt;img src=&quot;https://habrastorage.org/getpro/habr/post_images/fa7/7e6/27c/fa77e627c184bec95f61df62ccca0b54.jpg&quot; align=&quot;left&quot; width=&quot;288&quot; height=&quot;240&quot; alt=&quot;Big Fish Small Fry by John Pollack&quot; /&gt;&lt;/a&gt; Если Вы последние 10 лет провели на удаленном острове, без интернета и в отрыве от цивилизации, то специально для Вас мы попытаемся еще раз рассказать про концепцию MapReduce. Введение будет небольшим, в объеме достаточном, для реализации концепции MapReduce в среде InterSystems Caché. Если же Вы не сильно далеко удалялись последние 10 лет, то сразу переходите ко 2ой части, где мы создаем основы инфраструктуры.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;habracut /&gt;

&lt;p&gt;Давайте сразу определимся, я не являюсь большим поклонником MapReduce, о чем можно было догадаться по предыдущим моим статьям/переводам - &lt;a href=&quot;https://habrahabr.ru/post/270017/&quot;&gt;Майкл Стоунбрейкер — &quot;Hadoop на распутье&quot;&lt;/a&gt; и &lt;a href=&quot;https://habrahabr.ru/post/267697/&quot;&gt;&quot;Утилиты командной строки могут быть в 235-раз быстрее вашего Hadoop кластера&quot;&lt;/a&gt; [Если быть точнее, я не являюсь поклонником Java реализаций Hadoop MapReduce, но это уже личное]&lt;/p&gt;

&lt;p&gt;В-любом случае, несмотря на все эти оговорки и недостатки, есть еще множество причин, которые заставляют вернуться к этой теме и попытаться реализовать MapReduce в другой среде и на другом языке. Все это мы озвучим позже, но до этого поговорим про BigData…&lt;/p&gt;

&lt;h2 id=&quot;когда-data-большая-а-когда-маленькая&quot;&gt;Когда Data большая, а когда маленькая?&lt;/h2&gt;

&lt;p&gt;Несколько лет назад все стали сходить с ума по BigData, никто правда не знал когда его маленькие данные становятся большими, и где тот предел, но все понимали что это модно, молодёжно и «так» надо делать. Время шло, кое-кто объявил, что BigData уже не buzzword (это довольно таки забавно, но Gartner &lt;a href=&quot;http://www.kdnuggets.com/2015/08/gartner-2015-hype-cycle-big-data-is-out-machine-learning-is-in.html&quot;&gt;реально убрал&lt;/a&gt; волевым решением BigData со своей кривой базвордов за 2016, обосновав это тем, что термин расщепился на другие). Вне зависимости от желания Gartner термин BigData еще среди нас, живее всех живых, и думаю самое время определиться с его пониманием.&lt;/p&gt;

&lt;p&gt;Например, понимаем ли мы до конца, когда наши «не очень большие данные» превращаются в «БОЛЬШИЕ ДАННЫЕ»?&lt;/p&gt;

&lt;p&gt;Наиболее конкретный (из разумных) ответов дал Дэвид Кантер, один из самых уважаемых экспертов по архитектуре процессоров в целом и x86 в частности1:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;ru&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&amp;quot;&lt;a href=&quot;https://twitter.com/jrk&quot;&gt;@jrk&lt;/a&gt;: This: &lt;a href=&quot;http://t.co/PSWxSjAbnA&quot;&gt;http://t.co/PSWxSjAbnA&lt;/a&gt;&amp;quot; data isn&amp;#39;t big until it cannot be held in DRAM on a 2S server. Today that is &amp;gt;3TB &lt;a href=&quot;https://twitter.com/hashtag/bigdata?src=hash&quot;&gt;#bigdata&lt;/a&gt; &lt;a href=&quot;https://twitter.com/hashtag/myths?src=hash&quot;&gt;#myths&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Kanter (@TheKanter) &lt;a href=&quot;https://twitter.com/TheKanter/status/559034352474914816&quot;&gt;24 января 2015 г.&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;em&gt;FWIW, когда я, работая в Интеле, перешел в аппаратную команду, работающую над «процессором следующего поколения» (don'task), то я начал с изучения материалов про &lt;a href=&quot;http://www.realworldtech.com/nehalem/&quot;&gt;архитектуру процессора&lt;/a&gt; &lt;a href=&quot;http://www.realworldtech.com/nehalem/&quot;&gt;Nehalem&lt;/a&gt; на сайте Дэвида Кантера, а не с внутренних доков HAS и MAS. Потому как у Дэвида было лучше, и понятнее.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Т.е. если у вас «всего пара терабайт» данных, то вы, скорее всего, сможете найти аппаратную конфигурацию серверной машины, достаточную для того, чтобы все данные поместились в памяти сервера (при достаточном, конечно, количестве денег и мотивации), и ваши данные еще не совсем Большие.&lt;/p&gt;

&lt;p&gt;BigData начинаются когда такой подход с вертикальным масштабированием (нахождением «более лучшей» машины) перестают работать, т.к. с определенного размера данных вы уже не можете купить большей конфигурации, ни за какие (разумные) деньги. И надо начинать расти вширь.&lt;/p&gt;

&lt;h2 id=&quot;проще--лучше&quot;&gt;Проще – лучше&lt;/h2&gt;

&lt;p&gt;Ок, определившись с какого размера у нас данные выросли до термина BigData, мы должны определиться с подходами, которые работают на больших данных. Одним из первых подходов, который начал массово применяться на больших данных был &lt;a href=&quot;https://en.wikipedia.org/wiki/MapReduce&quot;&gt;MapReduce&lt;/a&gt;. Существует множество альтернативных программных моделей, работающих с большими данными, которые могут даже оказаться лучше или гибче чем MapReduce, но тот, однозначно может считаться самым упрощенным, хотя может быть и не самым эффективным.&lt;/p&gt;

&lt;p&gt;Более того, как только мы начинаем рассматривать какую-то программную платформу, или платформу баз данных, на предмет поддержки BigData, мы по умолчанию предполагаем, что MapReduce сценарий поддерживается на этой платформе внутренними или внешними утилитами.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Другими словами – без MapReduce ты не можешь утверждать, что твоя платформа поддерживает BigData!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ALARM – если вы все же были не на луне последние 10 лет, то можете смело проматывать рассказ про основы алгоритма MapReduce, скорее всего, вы уже в курсе. Для остальных мы попытаемся (еще раз) рассказать про то, с чего это все начиналось, и как этим всем можно воспользоваться в конце 2016 года. (Особенно на платформах, где MapReduce не поддерживается из коробки.)&lt;/p&gt;

&lt;p&gt;Часто было замечено, что самый простой подход к решению задачи позволяет получить наилучше результаты, и остаётся жить в продукте на продолжительное время. Вне от оригинального плана авторов. Даже если, в итоге, он не оказывается самым эффективным, но в силу того, что сообщество уже его широко узнало, и все изучили, и он просто достаточно хорош и решает задачи. Примерно такой эффект и наблюдается с моделью MapReduce – будучи очень простым в основе своей, он по-прежнему широко используется даже после того, &lt;a href=&quot;http://www.datacenterknowledge.com/archives/2014/06/25/google-dumps-mapreduce-favor-new-hyper-scale-analytics-system/&quot;&gt;как оригинальные авторы декларировали его смерть&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;масштабирование-в-caché&quot;&gt;Масштабирование в Caché&lt;/h2&gt;

&lt;p&gt;Исторически InterSystems Caché имел достаточно инструментов в своём арсенале, как для вертикального, так и горизонтального масштабирования. Как мы &lt;em&gt;все&lt;/em&gt; знаем (грустный смайл) Caché это не только сервер баз данных, но и сервер приложений, который может использовать ECP (Enterprise Cache Protocol) для горизонтального масштабирования и высокой доступности.&lt;/p&gt;

&lt;p&gt;Особенность ECP протокола –  будучи сильно оптимизированным протоколом для когерентности доступа к одним и тем же данным на разных узлах кластера, сильно упирается в производительность write daemon на центральном узле сервера БД. ECP позволяет добавить дополнительные счетные узлы с ядрами процессоров, если нагрузка на write-daemon не очень высокая, но этот протокол не поможет отмасштабировать ваше приложение горизонтально, если каждый из вовлеченных узлов порождает большую активность на запись. Дисковая подсистема на сервере БД по-прежнему будет узким местом.&lt;/p&gt;

&lt;p&gt;На самом деле, при работе с большими данными современные приложения предполагают использование другого, или даже ортогонального озвученном выше, подхода. Масштабировать приложение горизонтально надо с использованием дисковой подсистемы на каждом из узлов кластера. В отличие от ECP, где данные приносятся на удаленный узел, мы наоборот, приносим код, размер которого предполагается малым, к данным на каждом узле, размер которых предполагается очень большим (как минимум относительно размера данных). Похожий тип партиционирования, именуемый шардингом, в будущем будет реализован в SQL движке Caché в одном из &lt;em&gt;будущих&lt;/em&gt; продуктов. Но даже &lt;em&gt;сегодня&lt;/em&gt;, &lt;em&gt;на имеющихся в платформе средствах&lt;/em&gt;, мы можем реализовать нечто простое, что позволило бы нам спроектировать горизонтально масштабируемую систему, с применением современных, «модных, молодежных» подходов. Например, с применением MapReduce…&lt;/p&gt;

&lt;h2 id=&quot;google-mapreduce&quot;&gt;Google MapReduce&lt;/h2&gt;

&lt;p&gt;Оригинальная реализация MapReduce была написана в &lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/ru/archive/mapreduce-osdi04.pdf&quot;&gt;Google на Си++&lt;/a&gt;, но так получилось, что широкое распространение парадигмы началось в индустрии только с реализации MapReduce от Apache, которая на Java. В-любом случае, вне зависимости от языка реализации, идея остается одной и той же, будь та реализована на C++, Java, Go, или Caché ObjectScript, как в нашем случае.&lt;/p&gt;

&lt;p&gt;[Хотя, для Caché ObjectScript реализации мы воспользуемся парой трюков, доступных только при операциях с многомерными массивами, известными как &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_structure&quot;&gt;глобалы&lt;/a&gt;. Просто, потому что можем]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://habrastorage.org/files/56e/cc4/174/56ecc41743d0499f8f52272190f98af3.png&quot; align=&quot;center&quot; /&gt;
Рисунок 1. Исполнениевсреде MapReduce изстатьи &lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/ru/archive/mapreduce-osdi04.pdf&quot;&gt;&quot;MapReduce: Simplified Data Processing on Large Clusters&quot;, OSDI-2004&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Давайте пройдемся по стадиям алгоритма MapReduce, нарисованного в картинке выше:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;На входе у нас есть набор «файлов», или потенциально бесконечный поток данных, который мы можем разбить (партиционировать) на несколько независимых кусков данных;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Также имеем набор параллельных исполнителей (локальных внутри узла или может быть удаленных, на других узлах кластера) которые мы можем назначить как обработчиков входных кусков данных (стадия «отображение» /« &lt;strong&gt;map&lt;/strong&gt; »)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Эти параллельные обработчики читают входной поток данных и выводят в выходной поток пару(ы) «ключ-значение». Выходной поток может быть записан в выходные файлы или куда-то еще (например, в кластерную файловую систему Google GFS, Apache HDFS, или в какое другое «волшебное место» реплицирующее данные на несколько узлов кластера);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;На следующей стадии, именуемой «свертка» / « &lt;strong&gt;reduce&lt;/strong&gt; » у нас имеется другой набор обработчиков, которые занимаются (сюрприз) … сверткой. Они читают, для заданного ключа, всю коллекцию данных, и выводят результирующие данные как очередные «ключ-значения». Выходной поток этой стадии, аналогично предыдущей стадии, записывается в волшебные кластерные файловые системы или их аналоги.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Заметим, что MapReduce подход – пакетный по своей природе. Он не очень хорошо обрабатывает бесконечные потоки входных данных, в силу пакетной реализации, и будет ожидать завершения работы на каждой из его стадий («отображение» или «свертка»), перед тем как продвинуться дальше в конвейере. Этим он отличается от более современных поточных алгоритмов, используемых, например, в Apache Kafka, которые по своему дизайну нацелены на обработку «бесконечных» входных потоков.&lt;/p&gt;

&lt;p&gt;Знающие люди пропустили данный раздел, а незнающие, думаю, по-прежнему смущены. Давайте рассмотрим классический пример word-count (подсчет слов в потоке данных), который по традиции используется при объяснении реализации MapReduce на разных языках программирования, и в разных средах.&lt;/p&gt;

&lt;p&gt;Итак, допустим, нам надо подсчитать количество слов во входной коллекции (достаточно большой) файлов. Для ясности определимся, что словом будем считать последовательность символом между пробельными символами, т.е. цифры, знаки пунктуации также посчитаются частью слова, это, конечно, не очень хорошо, но в рамках простого примера это нас не волнует.&lt;/p&gt;

&lt;p&gt;Будучи Си++ разработчиком в глубинах своей души, для меня алгоритм становится ясен, когда я вижу пример на Си++. Если «Вы - не такой», то не расстраивайтесь, скоро мы его покажем в упрощенном виде.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#include &quot;mapreduce/mapreduce.h&quot;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// User's map function&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WordCounter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Skip past leading whitespace&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Find word end&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;REGISTER_MAPPER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WordCounter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// User's reduce function&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reducer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReduceInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Iterate over all entries with the&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// same key and add the values&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringToInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NextValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Emit sum for input-&amp;gt;key()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;REGISTER_REDUCER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceSpecification&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Store list of input files into &quot;spec&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MapReduceInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_filepattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_mapper_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WordCounter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Specify the output files:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// /gfs/test/freq-00000-of-00100&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// /gfs/test/freq-00001-of-00100&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceOutput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_filebase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/gfs/test/freq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_num_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_reducer_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Adder&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Optional: do partial sums within map&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// tasks to save network bandwidth&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_combiner_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Adder&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Tuning parameters: use at most 2000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// machines and 100 MB of memory per task&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_machines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_map_megabytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_reduce_megabytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Now run it&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MapReduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Done: 'result' structure contains info&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// about counters, time taken, number of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// machines used, etc.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Программа, приведенная выше, вызывается со списком файлов, которые надо обработать, переданным через стандартные argc/argv.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Объект MapReduceInput инстанциируется как обертка для доступа к каждому файлу из входного списка и планируется на исполнение классом WordCount для обработки его данных;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MapReduceOutput инстанциируется с перенаправлением выходных данных в кластерную файловую систему GoogleGFS (обратите внимание на /gfs/test/*)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Классы Reducer (свёртщик, хмм) и Combiner (комбинатор) реализуются Си++ классом Adder, текст которого приводится в этой же программе;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Функция Map в классе Mapper, реализованная в нашем случае в классе WordCouner, получает данные через обобщенный интерфейс MapInput.  Нашем случае этот интерфейс будет поставлять данные из файлов. Класс, реализующий данный интерфейс, должен реализовать метод value(), поставляющий следующую строку как string, и длину входных данных в методе size();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;В рамках решения нашего задания, подсчета количества слов в файле, мы будем игнорировать пробельные символы и считать все остальное, между пробелами как отдельное слово (вне зависимости от знаков пунктуации). Найденное слово пишем в выходной «поток» через вызов функции Emit(word, &quot;1&quot;);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Функция Reduce в классе реализации интерфейса Reducer (в нашем случае это Adder) получает свои входные данные через другой обобщенный интерфейс ReduceInput. Данная функция будет вызвана для определенного ключа (слова из файла, в нашем случае) из пары «ключ-значение», записанных на предыдущей стадии Map. Эта функция будет вызвана для обработки коллекции значений, советующих данному ключу (в нашем случае для последовательности «1»). В рамках нашего задания, ответственность функции Reducer - подсчитать количество таких единиц на входе и выдача суммарного числа в выходной канал.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Если у нас построен кластер из нескольких узлов, или просто запускается множество обработчиков в рамках алгоритма MapReduce, то ответственностью «мастера» будет разбить поток выдаваемых пар «ключ-значение» на соответствующие коллекции, и перенаправление этих коллекций на вход Reduce обработчикам.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Детали реализации такого мастер узла будут сильно зависеть от протокола реализации используемой технологии кластеризации, т.ч. мы опустим подробный рассказ об этом за скобками текущего повествования. В нашем случае, для Caché ObjectScript, для некоторых рассматриваемых алгоритмов (как текущий WordCount) мастер может быть реализован тривиально, в силу использования глобалов и их природы, как отсортированных, но разреженных массивов. О чем подробнее позже.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В общем случае, часто необходимо завести несколько шагов Reduce, например, для случаев, когда невозможно обработать полную коллекцию значений за один заход. И тогда появляется дополнительная(ые) стадия(ии) Combiner, которые будут дополнительно агрегировать результаты данных с предыдущих стадий Reduce.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если, после такого подробного описания Си++ реализации, вам по-прежнему непонятно что такое MapReduce, то давайте попробуем изобразить этот алгоритм на нескольких строках одного известного скриптового языка:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;EmitIntermediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;
   &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как в этом упрощенном примере видим, ответственностью функции map будет выдать последовательность пар &amp;lt;ключ, значение&amp;gt;. Эти пары перемешиваются и сортируются в мастере, и результирующие коллекции значений, для заданного ключа, отсылаются на вход функций reduce (свертка), которые, в свою очередь, ответственны за генерацию выходной пары &amp;lt;ключ,значение&amp;gt;. В нашем случае это будет &amp;lt;слово,счетчик&amp;gt;&lt;/p&gt;

&lt;p&gt;В классической реализации MapReduce трансформация коллекции пар &amp;lt;ключ,значение&amp;gt; в раздельные коллекции &amp;lt;ключ, значени(я)&amp;gt; является самой время- и ресурсоёмкой операцией. В случае же Caché реализации, как из-за природы реализации хранилищ btree*, так и связующего протокола ECP, сортировка и агрегация на мастере становятся не такой большой задачей, реализуемой почти на автомате, почти «забесплатно». Об этом мы расскажем при случае в следующих статьях.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Пожалуй, этого достаточно для вводной части – мы еще не затронули собственно Caché ObjectScript реализации, хотя и дали достаточно информации для начала реализации MapReduce на любом языке. К нашей реализации MapReduce мы вернемся в следующей статье. Оставайтесь на линии!&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Если Вы последние 10 лет провели на удаленном острове, без интернета и в отрыве от цивилизации, то специально для Вас мы попытаемся еще раз рассказать про концепцию MapReduce. Введение будет небольшим, в объеме достаточном, для реализации концепции MapReduce в среде InterSystems Caché. Если же Вы не сильно далеко удалялись последние 10 лет, то сразу переходите ко 2ой части, где мы создаем основы инфраструктуры.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature7.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Caché MapReduce - putting it all together – WordCount example (part III)</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-english-part-iii/" rel="alternate" type="text/html" title="Caché MapReduce - putting it all together – WordCount example (part III)" /><published>2016-09-06T20:56:00+00:00</published><updated>2016-09-06T20:56:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-english-part-iii</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-english-part-iii/">&lt;p&gt;&lt;em&gt;In &lt;a href=&quot;https://community.intersystems.com/post/cach%C3%A9-mapreduce-introduction-bigdata-and-mapreduce-concept&quot;&gt;part I&lt;/a&gt; of this series we have introduced MapReduce as a generic concept, and in &lt;a href=&quot;https://community.intersystems.com/post/cach%C3%A9-mapreduce-basic-interfaces-mapreduce-implementation-part-ii&quot;&gt;part II&lt;/a&gt; we started to approach Caché ObjectScript implementation via introducing abstract interfaces. Now we will try to provide more concrete examples of applications using MapReduce.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;!--break--&gt;&lt;/p&gt;&lt;h2&gt;WordCount – Simple sequential implementation&lt;/h2&gt;&lt;p&gt;MapReduce is all about parallelization and scalability. But let admit– it is very hard to understand and debug applications if they are parallel from the beginning. For simplicity sake we rather start from sequential version of wordcount algorithm, and then will add some parallelism.&lt;/p&gt;&lt;p&gt;Sequential mapper is quite simple and as expected:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Sample.WordCount.Mapper Extends (%RegisteredObject, MR.Base.Mapper)
{

/// read strings from MR.Base.Iterator and count words
Method Map(MapInput As MR.Base.Iterator, MapOutput As MR.Base.Emitter)
{
    while 'MapInput.IsAtEnd() {
        #dim line As %String = MapInput.GetNext()
        //#dim pattern As %Regex.Matcher = ##class(%Regex.Matcher).%New(&quot;[\w]+&quot;)
        #dim pattern As %Regex.Matcher = ##class(%Regex.Matcher).%New(&quot;[^\s]+&quot;)
        set pattern.Text = line
        while pattern.Locate() {
            #dim word As %String = pattern.Group
            do MapOutput.Emit(word)
        }
    }
}}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It receives input stream via MapInput, and emits data to the MapOutput. The algorithm is obvious –if there is some input data in the stream (i.e. &lt;em&gt;Not Map.Input.IsAtEnd()&lt;/em&gt;) – it will read a next line using MapInput.GetNext(), will split it to words via %Regex.Matcher (see &lt;a href=&quot;https://community.intersystems.com/post/using-regular-expressions-cach%C3%A9&quot;&gt;Using Regular Expression in Caché&lt;/a&gt; ), and each found word will be sent to output emitter.&lt;/p&gt;
&lt;p&gt;Reducer is even simpler:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Sample.WordCount.Adder Extends (%RegisteredObject, MR.Base.Reducer)
{

Method Reduce(ReduceInput As MR.Base.Iterator, ReduceOutput As MR.Base.Emitter)
{
    #dim result As %Numeric = 0
    while 'ReduceInput.IsAtEnd() {
        #dim value As %String = ReduceInput.GetNext() ; get &amp;amp;lt;key,value&amp;amp;gt; in $listbuild format
        #dim word As %String = $li(value,1)
        #dim count As %Integer = +$li(value,2)
        set result = result + count
    }
    do ReduceOutput.Emit(&quot;Count&quot;, result)
}

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there is no end of stream (&lt;em&gt;‘ReduceInput.IsAtEnd()&lt;/em&gt;) it continue to consume input ReduceInput stream, and at each iteration it receives pair in listbuild format (i.e. &lt;em&gt;$lb(word,count)&lt;/em&gt;). This function aggregates total word count in “result” variable, and emits final result to the next stage of MapReduce algorithm via ReduceOutput “pipe”.&lt;/p&gt;

&lt;p&gt;So, now we have shown mapper and reducer, but how main part of applications connects them together? It might get complex soon, but for the beginning we will start from &lt;em&gt;sequential&lt;/em&gt; implementation of a wordcount algorithm which still will be using MapReduce idiom (yes, I know this makes no much sense if work sequentially, but this simplification step is necessary before making it work in parallel or even on remote nodes).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/// Very simple, single-threaded &quot;map-reduce&quot; example.
/Class MR.Sample.WordCount.App Extends %RegisteredObject
{

ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new
    //kill ^mtemp.Map,^mtemp.Reduce

    #dim infraPipe As MR.Sample.GlobalPipe = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))

    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;

        // map
        #dim inputFile As MR.Input.FileLines = ##class(MR.Input.FileLines).%New(FileName)
        #dim mapper As MR.Sample.WordCount.Mapper = ##class(MR.Sample.WordCount.Mapper).%New()

        do mapper.Map(inputFile, infraPipe)

        // reduce
        #dim outPipe As MR.Base.Emitter = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
        #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()

        while 'infraPipe.IsAtEnd() {
            do reducer.Reduce(infraPipe, outPipe)
        }
        do outPipe.Dump()
    }
    quit

DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt
    ;;
}

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let me try explain this code line by line:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;We need to disable procedure block symbol allocation semantics [ProcedureBlock = 0] because we will use array of literal constants embedded to the code under DATA tag and used via $TEXT function. There we store the text (filenames) we plan to work with. For this particular example we use texts of 4 volumes of “War and Peace” by Leo Tolstoy;&lt;/li&gt;&lt;li&gt;As an intermediate global storage we will use ^mtemp.Map($J) and ^mtemp.Reduce($J) globals. They are &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCPF_Namespace_n&quot;&gt;automatically mapped to CACHETEMP&lt;/a&gt;, thus will not be journaled inside of transactions, and will be not evicted to persistent store as long as it’s possible. Consider them as “kind of in-memory” global;&lt;/li&gt;&lt;li&gt;Intermediate pipe infraPipe will be instance of MR.Sample.GlobalPipe class, which is alias to MR.EmitterSorted class (and, if you remember from &lt;a href=&quot;https://community.intersystems.com/post/cach%C3%A9-mapreduce-basic-interfaces-mapreduce-implementation-part-ii&quot;&gt;Part II&lt;/a&gt;, which is automatically cleaned up at the end of this program);&lt;/li&gt;&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Sample.GlobalPipe Extends (%RegisteredObject, MR.Emitter.Sorted) { }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;&lt;li&gt;We loop over $text(DATA+i) lines, and retrieve the 3&lt;sup&gt;rd&lt;/sup&gt; argument of string, delimited by “;” character. If result is not empty – we use the retrieved value as a file name to input text.&lt;/li&gt;&lt;li&gt;Input iterator for the mapper will be instance of MR.Input.FileLines, which we did not show yet. The class is rather simple:&lt;/li&gt;&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Input.FileLines Extends (%RegisteredObject, MR.Base.Iterator)
{

Property File As %Stream.FileCharacter;
Method %OnNew(FileName As %String) As %Status
{
    set ..File = ##class(%Stream.FileCharacter).%New()
    #dim sc As %Status = ..File.LinkToFile(FileName)
    quit sc
}

Method GetNext() As %String
{
    if $isobject(..File) &amp;amp;amp;&amp;amp;amp; '..File.AtEnd {
        quit ..File.ReadLine()
    }
    quit &quot;&quot;
}

Method IsAtEnd() As %Boolean
{
    quit '$isobject(..File) || ..File.AtEnd
}

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, returning back to the MR.Sample.WordCount.App application we write today:&lt;/p&gt;

&lt;ul&gt;
        &lt;li&gt;Mapper object will be instance of the already known MR.Sample.WordCount.Mapper (see above). Instance objects will be created separately for each individual file;&lt;/li&gt;
        &lt;li&gt;In the loop we sequentially invoke Map function in the mapper object created, passing input iterator opened for a file. In this case map stage is actually linearized in the sequential loop, and this is not typical for MapReduce, but this is good for education purposes;&lt;/li&gt;
        &lt;li&gt;At the reduce stage we have: output emitter pipe (outPipe) is the instance of MR.Emitter.Sorted, pointing to ^mtemp.Reduce($J). Do you still remember what is the specific of the MR.Emitter.Sorted class (why it’s &lt;em&gt;sorted&lt;/em&gt;)? Because it relies on btree* nature of global storage, and key-values pairs stored there become naturally sorted in the underlying persistent store. Furthermore we could immediately proceed “auto-increment” for values sent to the pipe.&lt;/li&gt;
        &lt;li&gt;Reducer object is an instance of MR.Sample.WordCount.Adder described &amp;lt;&amp;lt;above&amp;gt;&amp;gt;.&lt;/li&gt;&lt;li&gt;For each opened file (at the same iteration of a larger loop) we call reducer.Reduce function, passing there as arguments the intermediate pipe created (infraPipe object modified at the Map step), and output pipe as 2&lt;sup&gt;nd&lt;/sup&gt; argument;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Enough said, let see how it works?&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;DEVLATEST:MAPREDUCE:23:53:27:.000203&amp;gt;do &lt;span class=&quot;c&quot;&gt;##class(MR.Sample.WordCount.App).MapReduce()&lt;/span&gt;
^mtemp.Reduce&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3276,&lt;span class=&quot;s2&quot;&gt;&quot;Count&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)=&lt;/span&gt;114830
^mtemp.Reduce&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3276,&lt;span class=&quot;s2&quot;&gt;&quot;Count&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)=&lt;/span&gt;123232
^mtemp.Reduce&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3276,&lt;span class=&quot;s2&quot;&gt;&quot;Count&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)=&lt;/span&gt;130276
^mtemp.Reduce&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3276,&lt;span class=&quot;s2&quot;&gt;&quot;Count&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)=&lt;/span&gt;109344&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For each book opened, we have calculated the corresponding number of words in this volume, which then sequentially displayed at the end of iteration. We still have 2 questions unanswered:&lt;/p&gt;

&lt;ul&gt;
        &lt;li&gt;What is the final, aggregated number of words in all volumes?&lt;/li&gt;
        &lt;li&gt;And, what is actually more important at the moment, do we actually sure that these numbers were correct? [How to validate them?]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will start from the 2&lt;sup&gt;nd&lt;/sup&gt; question – verification is easy, given standard Linux/Unix/Cygwin GNU &lt;em&gt;wc&lt;/em&gt; utility.&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;Timur@TimurYoga2P /cygdrive/c/Users/Timur/Documents/mapreduce/data

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; war&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.txt
 114830 war_and_peace_vol1.txt
 123232 war_and_peace_vol2.txt
 130276 war_and_peace_vol3.txt
 109344 war_and_peace_vol4.txt
 477682 total&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So wordcounts calculated for each separate volume were correct, so we could proceed and implement aggregation.&lt;/p&gt;

&lt;h3&gt;Modified Reducer – now with summary counted&lt;/h3&gt;

&lt;p&gt;To implement aggregation we need to introduce 2 simple changes to the code we have created:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;We will use “extract to function” refactoring for part of Mapper code, because at a later steps we need to have it as &lt;em&gt;classmethod&lt;/em&gt;, and not have it embedded to the main code. This will significantly simplify future parallelization efforts and will even make possible to invoke it via remote execution (hopefully);&lt;/li&gt;&lt;li&gt;And secondly, we will move out instantiation of a reducer and Reduce function invocation from the loop. The idea is to not kill resultant pipe at end of each iteration, but rather accumulate whole data (automatically counting aggregated data for all 4 volumes to be processed);&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;In all other aspects these 2 samples are equal – they both open ^mtemp.Map($J) and ^mptemp.Reduce($J) as map and reduce step intermediate and final data storage.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Sample.WordCount.AppSum Extends %RegisteredObject
{

ClassMethod Map(FileName As %String, infraPipe As MR.Sample.GlobalPipe)
{
    #dim inputFile As MR.Input.FileLines      = ##class(MR.Input.FileLines).%New(FileName)
    #dim mapper As MR.Sample.WordCount.Mapper = ##class(MR.Sample.WordCount.Mapper).%New()

    do mapper.Map(inputFile, infraPipe)
}

ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new

    #dim infraPipe As MR.Sample.GlobalPipe    = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))
    #dim outPipe As MR.Base.Emitter           = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
    #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()

    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;

        do ..Map(fileName, infraPipe)
        //do infraPipe.Dump()

    }
    while 'infraPipe.IsAtEnd() {
        do reducer.Reduce(infraPipe, outPipe)
    }
    do outPipe.Dump()

    quit

DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol4.txt
    ;;
}

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;


&lt;h3&gt;Parallel implementation&lt;/h3&gt;

&lt;p&gt;Let admit it - changing the simple word-count algorithm, working over several files, to use MapReduce paradigm was not very convenient and very obvious, so this is not the 1&lt;sup&gt;st&lt;/sup&gt; thing you might try to do in real life. But potential gains well worth the pain introduced: reasonable parallelism may allow to achieve the time not possible in sequential algorithm (in my case, for example, sequential algorithm time was ~4.5 seconds, but parallel version completed in 2.6 seconds. Not &lt;em&gt;that&lt;/em&gt; much different, but still is respected improvement (taking into account the small input volume set, and limitations of my Haswell 2 low-power core laptop).&lt;/p&gt;

&lt;p&gt;Quite recently we have extracted Map stage into the separate class-method, providing it 2 arguments, input file name and output global name. We have done it on purpose - this separate function now is easy to parallelize, if we use standard Caché ObjectScript worker services (&lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr&quot;&gt;$system.WorkMgr&lt;/a&gt;). This version below is further modification of a sequential version we have created recently, but with few more workers added to the formula.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/// Version #2 More advanced, multiple-workers &quot;map-reduce&quot; example.
Class MR.Sample.WordCount.AppWorkers Extends %RegisteredObject
{

ClassMethod Map(FileName As %String, InfraPipeName As %String) As %Status
{
    #dim inputFile As MR.Input.FileLines        = ##class(MR.Input.FileLines).%New(FileName)
    #dim mapper As MR.Sample.WordCount.Mapper   = ##class(MR.Sample.WordCount.Mapper).%New()
    #dim infraPipe As MR.Sample.GlobalPipeClone = ##class(MR.Sample.GlobalPipeClone).%New(InfraPipeName)

    do mapper.Map(inputFile, infraPipe)

    quit $$$OK
}

ClassMethod MapReduce() [ ProcedureBlock = 0 ]
{
    new
    #dim infraPipe As MR.Sample.GlobalPipe = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J)))
    #dim outPipe As MR.Base.Emitter = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J)))
    #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New()

    #dim sc As %Status = $$$OK
    // do $system.WorkMgr.StopWorkers()
    #dim queue As %SYSTEM.WorkMgr = $system.WorkMgr.Initialize(&quot;/multicompile=1&quot;, .sc)
    quit:$$$ISERR(sc)

    for i=1:1 {
        #dim fileName As %String = $piece($Text(DATA+i),&quot;;&quot;,3)
        quit:fileName=&quot;&quot;

        //do ..Map(fileName, infraPipe)
        set sc = queue.Queue(&quot;##class(MR.Sample.WordCount.AppWorkers).Map&quot;, fileName, infraPipe.GlobalName)
        quit:$$$ISERR(sc)
    }
    set sc = queue.WaitForComplete() quit:$$$ISERR(sc)

    while 'infraPipe.IsAtEnd() {
        do reducer.Reduce(infraPipe, outPipe)
    }
    do outPipe.Dump()

    quit

DATA
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol1.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol2.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol3.txt
    ;;C:\Users\Timur\Documents\mapreduce\data\war_an_peace_vol4.txt
    ;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The difference between prior AppSum and current AppWorkers is subtle, but important – instead of directly calling Map function in the class, we call this function via $system.WorkMgr.Queue API. This API allows to call either bare routine, or class-method, like the one created in our case. But such inter-processes communications, while providing extra functionality, came with extra limitations – we may not pass anything beyond simple scalar values (i.e. numbers and strings).&lt;/p&gt;

&lt;p&gt;In the MR.Sample.WordCount.AppSum::Map case the 2&lt;sup&gt;nd&lt;/sup&gt; argument was an object of MR.Sample.GlobalPipe class. We can not pass object instances to workers, and, in general, when we need to pass object between processes (parent and worker in our case) we need to invent some “serializing/deserializing” schema (hopefully simple). For GlobalPipe “simple serialization” is truely simple – we just pass a name of a global used. That’s why the 2&lt;sup&gt;nd&lt;/sup&gt; argument in our MR.SampleWordCount.AppWorkers::Map function becomes the string of global name, not the object.&lt;/p&gt;

&lt;p&gt;Please see workers documentation &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr&quot;&gt;here&lt;/a&gt;, but, in general, if we want to rely on workers heuristics (to use as much workers as we have available [licensed] hardware cores) then we need to initialize workers with oddly named “/multicompile=1” modifier. [This modifier initially used for the parallel compilation in the ObjectScript class compiler, thus this strange name inherited]. Once we queued class-method calls and their arguments via &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr#Queue&quot;&gt;$system.WorkMgr.Queue&lt;/a&gt; call, we need to invoke them all and wait completion of all via &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25SYSTEM.WorkMgr#Queue&quot;&gt;$system.WorkMgr.WaitForComplete&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All concurrent mappers will use the same temporary global (infraPipe) to output intermediate results, but we will not observe any visible collision effect due to appropriate database engine support (Caché database engine is inherently multi-process, by design). If there will be a chance we will return back to the topic of locking and lockless concurrent algorithms and data-structures.&lt;/p&gt;

&lt;p&gt;On the other hand, reducer here will be invoked from the single thread (from parent, master process, in our case), because we need to calculate the aggregated sum for all intermediate data. That is why reducer is invoked outside of worker loop.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In this series &lt;a href=&quot;../mapreduce-english-part-i/&quot;&gt;we have introduced MapReduce algorithm in general&lt;/a&gt;, &lt;a href=&quot;../mapreduce-english-part-ii/&quot;&gt;covered basic infrastructure necessary for MapReduce in Caché ObjectScript&lt;/a&gt; and have created 1st rather simple MapReduce example counting words in the input stream(s). The next step we will continue cover MapReduce idioms using&amp;nbsp;classic example – now it will AgeAverage example from WikiPedia. Stay tuned.&lt;/em&gt;&lt;/p&gt;</content><author><name>Timur Safin</name></author><summary type="html">In part I of this series we have introduced MapReduce as a generic concept, and in part II we started to approach Caché ObjectScript implementation via introducing abstract interfaces. Now we will try to provide more concrete examples of applications using MapReduce.WordCount – Simple sequential implementationMapReduce is all about parallelization and scalability. But let admit– it is very hard to understand and debug applications if they are parallel from the beginning. For simplicity sake we rather start from sequential version of wordcount algorithm, and then will add some parallelism.Sequential mapper is quite simple and as expected:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature8.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Caché MapReduce - Basic interfaces for MapReduce implementation (part II)</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-english-part-ii/" rel="alternate" type="text/html" title="Caché MapReduce - Basic interfaces for MapReduce implementation (part II)" /><published>2016-09-01T20:56:00+00:00</published><updated>2016-09-01T20:56:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-english-part-ii</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-english-part-ii/">&lt;p&gt;&lt;em&gt;In the &lt;a href=&quot;../mapreduce-english-part-i/&quot;&gt;prior part of this series&lt;/a&gt; we have provided introduction to Google MapReduce approach, but still not covered their possible ObjectScript implementation. Which we will start to explain today.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;!--break--&gt;&lt;/p&gt;
&lt;p&gt;We still plan to model Caché ObjectScript MapReduce implementation quite close to the original Google C++ example given before. We start from Mapper and Reducer abstract interfaces which will be implemented elsewhere later:&lt;/p&gt;&lt;div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/// Base class for MapReduce Mapper.
Class MR.Base.Mapper 
{

Method Map(MapInput As MR.Base.Iterator, MapOutput As MR.Base.Emitter) [ Abstract ] { }

}


/// Base class for MapReduce Reducer.
Class MR.Base.Reducer
{
Method Reduce(ReduceInput As MR.Base.Iterator, ReduceOutput As MR.Base.Emitter) [ Abstract ] { }

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;
&lt;p&gt;Originally, we’ve started with separate implementations of MapInput and ReduceInput interface classes (as in C++), but then we’ve realized that they are about the same – iteration over the stream, until there is end reached, so they got unified to the common MR.Base.Iterator:&lt;/p&gt;
&lt;div&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Abstract&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsAtEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Abstract&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/div&gt;

&lt;h2&gt;Using globals as a channel&lt;/h2&gt;

&lt;p&gt;Original Google MapReduce implementation used Google GFS cluster file-system as a transport media between nodes for intermediate and final storage. We have different media to establish interaction between cluster Caché nodes and it’s called – &lt;a href=&quot;http://docs.intersystems.com/documentation/cache/latest/pdfs/GDDM.pdf&quot;&gt;Enterprise Cache Protocol (ECP)&lt;/a&gt;. Right now it’s used by application servers for operating with remote data mounted from data server, but there is nothing stopping us from using ECP as a simple “control bus” interface, where we will put &amp;lt;key, value&amp;gt; pairs or similar operating data from the sender side and retrieve those commands on the receiver side. If implementation actors (i.e. reduce and combine workers) will be running on the same machine, then they could even use ultra-fast, scratch data space on the CACHETEMP&lt;/p&gt;
&lt;div&gt;&lt;p&gt;&lt;cite&gt;If there would be inheritance implemented between parent and child processes for process-private globals opened by parent ^||PPG, or may be some magical locals be automatically marshalled between processes, then PPG or inherited local arrays would be much more convenient to use here, for emitter operations. Dreams, dreams…&lt;/cite&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Either way, be they local for the particular node, or, may be, mapped remotely via ECP, &lt;em&gt;globals&lt;/em&gt; are very convenient, and well established mechanism, which is very fitting as transport for sending intermediate data between MapReduce stages. Let try to use it this way.&lt;/p&gt;
&lt;h2&gt;Emitters and some dirty magic&lt;/h2&gt;
&lt;p&gt;You remember that between moment when data is emitted from mapper, and when element of a collection retrieved by reducer there is some heavy shuffle algorithm used on master node. Actually, in the MUMPS/ObjectScript environment, we could entirely avoid this overhead if we will use some built-in functions, which will handle aggregation for us. Luckily, all this aggregation can be done without any extra traffic between involved parties (master, mapper or reducer). [&lt;em&gt;More details about this handy optimization will be given later&lt;/em&gt;]&lt;/p&gt;
&lt;p&gt;Here is basic emitter interface we introduce:&lt;/p&gt;
&lt;div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Class MR.Base.Emitter Extends MR.Base.Iterator
{

/// emit $listbuild(key,value(s))
Method Emit(EmitList... As %String) [ Abstract ] { }

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Semantically, emitter is very similar to input iterator (thus we see it’s ancestor of MR.Base.Iterator), but in addition to iterator interface we will introduce some extra functions which will send data to the intermediate collection (e.g. Emit function).&lt;/p&gt;
&lt;div&gt;&lt;p&gt;At the beginning of the MapReduce project our Emit function was very close to classical one, it was accepting 2 arguments for simple case of &amp;lt;key, value&amp;gt; pair. But then we’ve discovered some necessity to extend it to something more multi-dimensional (i.e. handling generic tuples), thus right now it’s accepting variable number of arguments (though, most of the time there are either single or 2 arguments passed).&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;This is still abstract interface, and more “meat” will be added quite soon:&lt;/p&gt;
&lt;p&gt;If we need to keep the order of emitted data then we could use implementation similar to MR.Emitter.Ordered:&lt;/p&gt;
&lt;div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/// Emitter which maintains the order of (key,value(s))
Class MR.Emitter.Ordered Extends (%RegisteredObject, MR.Base.Emitter)
{

­­/// global name serving as data channel
Property GlobalName As %String;

Method %OnNew(initval As %String) As %Status
{
    $$$ThrowOnError($length(initval)&amp;amp;gt;0)
    set ..GlobalName = initval
    quit $$$OK
}

Parameter AUTOCLEANUP = 1;
Method %OnClose() As %Status
{
    if ..#AUTOCLEANUP {
        if $data(@i%GlobalName) {
            kill @i%GlobalName
        }
    }
    Quit $$$OK
}

…&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;
&lt;p&gt;Globals are global, and they not automatically cleaned up, once process, which has created them, will be terminated. But in our case we use globals as rather intermediate, not as a persistent storage, so sometimes we do need to proceed automatic cleanup. That’s why we have introduced #AUTOCLEANUP class parameter (which is enabled by default, so the global those name is stored to GlobalName property, will be killed at the moment emitter is deleted (see %OnClose callback). Please pay attention that there is 1 required parameter we enforce in the %New() constructor of this class – it expects to receive global name with whom we will operate.&lt;/p&gt;
&lt;div&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;…

Method IsAtEnd() As %Boolean
{
    quit ($data(@i%GlobalName)\10)=0
}

/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim list As %String = &quot;&quot;
    for i=1:1:$get(EmitList) {
        set $li(list,i) = $get(EmitList(i))
    }
    #dim name As %String = ..GlobalName
    set @name@($seq(@name)) = list
}

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim value As %String
    #dim index As %String = $order(@i%GlobalName@(&quot;&quot;),1,value)
    if index'=&quot;&quot; {
        kill @i%GlobalName@(index)
        quit value
    } else {
        kill @i%GlobalName
        quit &quot;&quot;
    }
}

Method Dump()
{
    zwrite @i%GlobalName
}

}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;
&lt;p&gt;Do you still remember that Emitter is ancestor of Iterator, so it supposed to implement not only Emit function but IsAtEnd and GetNext as well?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IsAtEnd is simple – if there are data in the global (i.e. $data returns 1x) then we assume collection is not empty.&lt;/li&gt;&lt;li&gt;Emit creates new node at the end of global, keeping passed argument list in $listbuild(list) format. As you already aware, $sequential function could be used (almost) at the same cases when $increment is used, but it has one big advantage for us – their performance observes less contention over global mode used if it’s working over ECP (see &lt;a href=&quot;https://community.intersystems.com/post/sequence-function&quot;&gt;&quot;On $Sequence function&quot;&lt;/a&gt; by Alexander Koblov)&lt;/li&gt;&lt;li&gt;On the other hand GetNext() retrieves head of a collection ($order(@i%GlobalName@(“”)) and then delete the head. To pass &amp;lt;key,value&amp;gt; pair we use $lb&amp;lt;&amp;gt; data structure. Lists created by $listbuild() function allow to keep not only simple (key, value) pair, but tuple of any desired size. We will use this ability later.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Data structure as implemented by MR.Emitter.Ordered is a classical FIFO (“First in – First Out”) collection: we push data at the end, and pop from the head.&lt;/p&gt;

&lt;h2&gt;Autoaggregating emitter&lt;/h2&gt;

&lt;p&gt;If you look into the sorted collection implementation, and compare to what we send in word-count example, then you will immediately recognize that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Actually, we do not care about order we send keys to emitter. After we write them unordered as keys (subscript values) of some particular global node they to be automatically sorted by the underlining btree* database storage;&lt;/li&gt;&lt;li&gt;And in majority of cases when we emit &amp;lt;word, 1&amp;gt; in mapper then we assume to proceed in the reducer the simple aggregation of those 1s, essentially, it will work as simple $increment counter.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;So why bother and produce unnecessary traffic if we could use magical $increment from ObjectScript?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/// Emitter which sorts by keys all emitted pairs or tuples (key, value(s))
Class MR.Emitter.Sorted Extends MR.Emitter.Ordered
{

Property AutoIncrement As %Boolean [ InitialExpression = 1 ];

/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim name As %String = ..GlobalName
    #dim key As %String
    #dim value As %String 

    if $get(EmitList)=1 {
        // special case - only key name given, no value
        set key = $get(EmitList(1))
        quit:key=&quot;&quot;
        if ..AutoIncrement {
            #dim dummyX As %Integer = $increment(@name@(key)) ; $seq is non-deterministic
        } else {
            set @name@(key) = 1
        }
    } else {
        set value = $get(EmitList(EmitList))
        set EmitList = EmitList - 1
        for i=1:1:$get(EmitList) {
            #dim index As %String = $get(EmitList(i))
            quit:index=&quot;&quot;
            set name = $name(@name@(index))
        }
        if ..AutoIncrement {
            #dim dummyY As %Integer = $increment(@name,value)
        } else {
            set @name = value
        }
    }
}

…&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There is simplest case, when there is 1 argument passed to Emit function (the key only). So if we are acting in AutoIncrement mode then we immediately count the sum of all key with the same name passed. If it’s not in autoincrementing mode, then we simply (re)define this key in global, holding 1 as the value.&lt;/p&gt;
&lt;p&gt;For 2 argument mode (key, value) and in autoincrementing mode, we accumulate in the corresponding node of a global the sum of all values passed so far.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;But there is more&lt;/em&gt; – this function is able to handle any size of a tuple &amp;lt;key, value(s)&amp;gt;, even more than 2. When there is no autoincrement enabled it’s still easy –emitter will just define an appropriate node in a global where all arguments passed to the functions become subscripts of a global node. On the other hand, for autoincrement mode it acts a little differently, and should consider last argument as value for multi-dimensional node, so all arguments before the last one will be subscript names.&lt;/p&gt;
&lt;p&gt;This unusual extension of a key-value nature data use in algorithm is not typical to our knowledge, we are unaware whether there is something similar used by other MapReduce implementations (probably, because of the fact they operate with strict key-value or bigtable stores, and not with hierarchical arrays like in our case, where efficient $increment facilities available). We’ll show later some practical example of such extension.&lt;/p&gt;
&lt;p&gt;IsAtEnd is still not redefined by this class, and is inherited from parent MR.Emitter.Ordered (i.e. it returns non-null value of there is some data under GloRef name used for intermediate store).&lt;/p&gt;
&lt;p&gt;But GetNext should be a little bit more complex than before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;…

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim name As %String = ..GlobalName
    #dim value As %String
    #dim ref As %String = $query(@name,1,value)
    if ref'=&quot;&quot; {
        zkill @ref
        #dim i As %Integer
        #dim refLen As %Integer = $qlength(ref)
        #dim baseLen As %Integer = $qlength(name)
        #dim listbuild = &quot;&quot;
        for i=baseLen+1:1:refLen {
            set $li(listbuild,i-baseLen)=$qs(ref,i)
        }
        set $li(listbuild,*+1)=value

        quit listbuild
    }

    quit &quot;&quot;
}

…&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We expect $LB&amp;lt;&amp;gt; data returned from the function, but Emit stores tuple data into global as subscripts, so we need to reassemble $listbuild from the subscripts and there stored node value. The returned node is immediately killed in the global so it will be removed from “collection” and not available for other workers.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In this 2&lt;sup&gt;nd&lt;/sup&gt; part of series we have introduced basic interfaces used by our ObjectScript MapReduce implementation. In a future parts we will put all things together, and will provide more concrete examples.&lt;/em&gt;&lt;/p&gt;</content><author><name>Timur Safin</name></author><summary type="html">In the prior part of this series we have provided introduction to Google MapReduce approach, but still not covered their possible ObjectScript implementation. Which we will start to explain today. We still plan to model Caché ObjectScript MapReduce implementation quite close to the original Google C++ example given before. We start from Mapper and Reducer abstract interfaces which will be implemented elsewhere later:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature9.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Caché MapReduce - introduction to BigData and MapReduce concept</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-english-part-i/" rel="alternate" type="text/html" title="Caché MapReduce - introduction to BigData and MapReduce concept" /><published>2016-08-18T20:56:00+00:00</published><updated>2016-08-18T20:56:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-english-part-i</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-english-part-i/">&lt;p&gt;Several years ago everyone got mad&amp;nbsp;about BigData – nobody knew when smallish data will become BIGDATA, but all knows
	that it’s trendy and the way to go. Time passed, BigData is not a buzz anymore (most of us missed the moment when Gartner
	has removed BigData term from their 2016 buzzword 2016 curve &lt;a href=&quot;http://www.kdnuggets.com/2015/08/gartner-2015-hype-cycle-big-data-is-out-machine-learning-is-in.html&quot;&gt;http://www.kdnuggets.com/2015/08/gartner-2015-hype-cycle-big-data-is-out-machine-learning-is-in.html&lt;/a&gt;),
	so it’s probably a good time to look back and realize what it is (what it was)…&lt;/p&gt;

&lt;h2&gt;When it becomes “BigData”?&lt;/h2&gt;

&lt;p&gt;Let’s start from the beginning: what is the moment when “not so big data” becomes BigData? Here was the answer in 2015 from
	David Kanter&lt;a href=&quot;#_ftn1&quot; name=&quot;_ftnref1&quot; title=&quot;&quot;&gt;[1]&lt;/a&gt;, one of most respected, well known x86 architecture specialists&lt;/p&gt;
&lt;!-- &lt;p&gt;&lt;a href=&quot;https://twitter.com/thekanter/status/559034352474914816&quot;&gt;https://twitter.com/thekanter/status/559034352474914816&lt;/a&gt;&lt;/p&gt; --&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;ru&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&amp;quot;&lt;a href=&quot;https://twitter.com/jrk&quot;&gt;@jrk&lt;/a&gt;: This: &lt;a href=&quot;http://t.co/PSWxSjAbnA&quot;&gt;http://t.co/PSWxSjAbnA&lt;/a&gt;&amp;quot; data isn&amp;#39;t big until it cannot be held in DRAM on a 2S server. Today that is &amp;gt;3TB &lt;a href=&quot;https://twitter.com/hashtag/bigdata?src=hash&quot;&gt;#bigdata&lt;/a&gt; &lt;a href=&quot;https://twitter.com/hashtag/myths?src=hash&quot;&gt;#myths&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Kanter (@TheKanter) &lt;a href=&quot;https://twitter.com/TheKanter/status/559034352474914816&quot;&gt;24 января 2015 г.&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;So if you have “only a couple” of terabytes data then you probably could find an appropriate hardware configuration which
	will held it entirely in memory, [well, given enough of motivation and budget], so it’s probably not yet “the BigData”.&lt;/p&gt;
&lt;p&gt;BIGDATA starts from the moment when vertical upscale approaches (finding bigger hardware) stop to work because there is no
	bigger hardware (which still is reasonably expensive) available at the moment, so you need to start to think rather horizontally,
	and not vertically.&lt;/p&gt;

&lt;h2&gt;Simpler the better - MapReduce&lt;/h2&gt;

&lt;p&gt;Ok, now we know volume size which would be threshold for BigData approach, then we need to figure out appropriate approach
	which we will use for handling such big volume. One of the first approaches started to be used with BigData was (and still
	is) the &lt;a href=&quot;https://en.wikipedia.org/wiki/MapReduce&quot;&gt;MapReduce&lt;/a&gt; programming model. There are multiple known programming
	models for big data which are probably simpler and may be more flexible than MapReduce, but MapReduce is definitely the
	most simplistic, well known, but not necessary the most efficient one.&lt;/p&gt;
&lt;p&gt;And, if one talks about some database platform as supporting BigData, he, most probably, means that platforms does support
	some MapReduce scenario using some built-in or external interfaces and infrastructure.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Putting it the other way: if there is no MapReduce – you could not claim BigData support in the platform!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you were outside of internet last 10 years and missed MapReduce then we will try to explain it in details quite soon,
	but for now please remember that MapReduce is a generic paradigm to get wide scalability effect using very simple (albeit
	not very much efficient) instruments.&lt;/p&gt;
&lt;p&gt;It's frequently observed that simplest approach allows to get better results, and, most probably, using least expensive way.
	Even being not the most efficient way, it will be used longer, and will have better chances to get widespread usage with
	easier learning curve.&lt;/p&gt;
&lt;p&gt;This effect has happened with MapReduce model, while being very simple one, it’s got widely used in many areas, where original
	authors could not even anticipate it at the beginning.&lt;/p&gt;
&lt;h2&gt;Caché specific scalability approaches&lt;/h2&gt;
&lt;p&gt;Historically, InterSystems Caché has many well established tools for both vertical and horizontal scalability: as we know
	it's not only the database server, but also is the application server, which uses ECP protocol for scalability and high-availability.&lt;/p&gt;
&lt;p&gt;The problem with ECP protocol – while being very much optimized for coherent parallel execution on many nodes, it still very
	dependent on the write daemon performance of a single node (central database server). ECP capabilities help you when you
	need to add extra CPU cores with the modest write-daemon activity, but not will help you to scale horizontally the write
	activity, because the database server will still be the bottleneck.&lt;/p&gt;
&lt;p&gt;Modern BigData applications implicitly assume the different or rather opposite approach – to scale performance horizontally
	using each particular node write capabilities. In reverse to ECP approach, when data is brought to application on several
	nodes, we rather assume that application size is thin/”reasonable” but data amount is enormous, so we better to bring code
	to the local data, and not the opposite. This sort of partitioning is named “sharding” and will be addressed in Caché SQL
	engine in general with some future InterSystems Caché solutions, but in a mean-time we could try to use some simpler, but
	already available means, using that we have &lt;em&gt;today&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Although, I’m not big fan of original BigData approach (see Mike Stonebraker articles &lt;a href=&quot;http://cacm.acm.org/blogs/blog-cacm/149074-possible-hadoop-trajectories/fulltext&quot;&gt;“Possible Hadoop Trajectories”&lt;/a&gt;,
	&lt;a href=&quot;http://cacm.acm.org/blogs/blog-cacm/177467-hadoop-at-a-crossroads/fulltext&quot;&gt;“Hadoop at a crossroads?”&lt;/a&gt;, [
	&lt;a
		href=&quot;https://habrahabr.ru/post/270017/&quot;&gt;Russian translation is here&lt;/a&gt; ]), and it’s not a panacea of any sorts, but MapReduce still may be a good start for future
		developments, so let us get whatever we have in the Caché as development platform, and implement some simplified MapReduce
		which may be still helpful for developers right away.&lt;/p&gt;
&lt;h2&gt;Google MapReduce&lt;/h2&gt;
&lt;p&gt;The original Google MapReduce implementation was in C++, but coincidentally, the wide usage in the industry MapReduce achieved
	only thanks Apache Hadoop implementation which was in the different language - Java. In any case, regardless of a particular
	implementation language, the idea is more or less the same, be it C++, Java, Go, or, in our case, Caché ObjectScript. [Though
	for ObjectScript case we will use a few shortcuts, which are possible thanks to hierarchical arrays capabilities also known
	as globals].&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/assets/google-apreduce-illustration_0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Figure: MapReduce Execution Overview from &quot;MapReduce: Simplified Data Processing on Large Clusters&quot;, OSDI-2004&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Here is the simplistic MapReduce algorithm depicted in the picture above:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;We have a bunch of input files or, potentially infinite, data stream, which we could somehow &lt;em&gt;partition&lt;/em&gt; to the number
		of independent chunks;&lt;/li&gt;
	&lt;li&gt;Also we have some number of &lt;em&gt;parallel workers&lt;/em&gt; (local to the current node or probably remote) which will be assigned
		to some input chunks (this is called “&lt;strong&gt;map phase&lt;/strong&gt;”);&lt;/li&gt;
	&lt;li&gt;Those workers proceed &lt;em&gt;input data stream&lt;/em&gt;(s) and then &lt;em&gt;emit&lt;/em&gt; output data in a simple key-value form to the
		&lt;em&gt;output stream&lt;/em&gt;(s).The output stream written to simple files or anywhere else (i.e. to cluster wide filesystem,
		like Google GFS or Apache HDFS, based on some external magic).&lt;/li&gt;
	&lt;li&gt;At the next stage, “&lt;strong&gt;reduce phase&lt;/strong&gt;“, we have another set of workers, which do their “reduction” work. They
		read value collections for some given key, and provide resultant key-value written to the output files (which are still
		residing on some magical cluster file-systems).&lt;/li&gt;
	&lt;li&gt;MapReduce approach is batch by their nature. It’s unable to handle true infinite input-streams and will wait completion
		of each stage (map or reduce) before going to the next pipeline. This is difference with more modern “streaming” approaches
		used in Apache Kafka, which could handle in parallel infinite input streams.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Is it clear? Probably, not yet. Let me try to clarify it using classical word-count example, given in the original Google’
	article.&lt;/p&gt;
&lt;p&gt;Consider a case when we need to count the number of unique words in the collection of files.&lt;/p&gt;
&lt;p&gt;I’m C++ developer in my background, so any algorithm became crystal clear once we see true C++ example. On the other hand,
	if you have no prior C++ knowledge then bear with me, I’ll try to explain it later, using simplified algorithmic language.&lt;/p&gt;
&lt;div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;mapreduce/mapreduce.h&quot;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// User's map function&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WordCounter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Skip past leading whitespace&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Find word end&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;REGISTER_MAPPER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WordCounter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// User's reduce function&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reducer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReduceInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Iterate over all entries with the&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// same key and add the values&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringToInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NextValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Emit sum for input-&amp;gt;key()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;REGISTER_REDUCER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceSpecification&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Store list of input files into &quot;spec&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MapReduceInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_filepattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_mapper_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WordCounter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Specify the output files:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// /gfs/test/freq-00000-of-00100&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// /gfs/test/freq-00001-of-00100&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceOutput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_filebase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/gfs/test/freq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_num_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_reducer_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Adder&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Optional: do partial sums within map&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// tasks to save network bandwidth&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_combiner_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Adder&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Tuning parameters: use at most 2000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// machines and 100 MB of memory per task&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_machines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_map_megabytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_reduce_megabytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Now run it&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MapReduceResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MapReduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Done: 'result' structure contains info&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// about counters, time taken, number of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// machines used, etc.&lt;/span&gt;
 
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;ol&gt;
	&lt;li&gt;
		&lt;p&gt;The program is invoked with the list of files it should process (passed in standard argc/argv);&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;MapReduceInput object instantiate with each input argument, and scheduled to run mapper class (WordCounter) for each input;&lt;/li&gt;
	&lt;li&gt;MapReduceOutput is instantiated to output data to some “magical” Google cluster filesystem (e.g. /gfs/test/*);&lt;/li&gt;
	&lt;li&gt;Reducer and combiner classes assigned to C++ class Adder, implemented in this same program;&lt;/li&gt;
	&lt;li&gt;Function Map in Mapper class (implemented by WordCounter class in our case) receives input data via generic MapInput interface.
		In this case it will be file reading interface. It gets content of this data source via value() function, and length of
		the data source via size() function;&lt;/li&gt;
	&lt;li&gt;For the purposes of the original exercise it should ignore all whitespaces (isspace(x)), and count anything between white-spaces
		as a word. The word found is then written to output stream via Emit(word, “1”) function;&lt;/li&gt;
	&lt;li&gt;Function Reduce, in the Reducer class (implemented by Adder class), receives reducer input data via generic ReduceInput
		interface. This function called for some particular key value (found word in the mapper stage) with the collection of all
		values sent for this key from mapper (sequence of 1 in our case). The responsibility of a reducer function is to count
		these 1s and emit their sum to the output channel.&lt;/li&gt;
	&lt;li&gt;This was responsibility of a MapReduce master to prepare such input collection of values for the given key. Details of particular
		implementation will heavily dependent of a protocol used in the cluster, so we will leave it outside of this story. In
		our case, for the Caché ObjectScript implementation it will be quite easy, thanks to sorted nature of globals.&lt;/li&gt;
	&lt;li&gt;There are cases when one or more extra reduce step(s) will be required (i.e. if 1&lt;sup&gt;st&lt;/sup&gt; reduce step didn’t process
		whole input data set), then there is Combiner step(s) used, which will aggregate the data collected by prior (1&lt;sup&gt;st&lt;/sup&gt;)
		reduce step. Depending on circumstances and algorithm used, you may need to use multiple combiner steps for aggregation
		of generated data.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Is it clear already? No? Ok, here is simplified description of the algorithm Google MapReduce implementation (which is looking
	like Python, but is not actual Python):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;EmitIntermediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Responsibility of a map function to generate list of &amp;lt;key,value&amp;gt; pairs. Those pairs shuffled and sorted elsewhere,
	on the controller nodes, and sent to reducer I consolidated collections for each separate key. Responsibility of reduce
	function – get collection of values for the given key, and generate the output key-value pair or list of such pairs. (The
	number of words for our case)&lt;/p&gt;
&lt;p&gt;In the classical MapReduce implementation transformation of a collection of &amp;lt;key, value&amp;gt; to the separate collections
	of &amp;lt;key, &amp;lt;value(s)&amp;gt;&amp;gt; is most time consuming operation. However, it will not be a such big deal in our Caché
	implementation, because b-tree* -based storage will do all the ground work for us, if we use global as our intermediate
	storage. More details later.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This is probably enough for the introduction part – we have not provided anything ObjectScript related, but have provide enough of details of MapReduce&amp;nbsp;algorithm for which the corresponding ObjectScript implementation will be shown in the later parts of this series. Stay tuned.&lt;/em&gt;&lt;/p&gt;
&lt;div&gt;&amp;nbsp;
	&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;&gt;
	&lt;div id=&quot;ftn1&quot;&gt;
		&lt;p&gt;&lt;a href=&quot;#_ftnref1&quot; name=&quot;_ftn1&quot; title=&quot;&quot;&gt;[1]&lt;/a&gt; FWIW, when I was in the Intel team which was developing &quot;next-generation&quot;
			processor architecture, I was using David Kanter' &lt;a href=&quot;http://www.realworldtech.com/nehalem/&quot;&gt;Nehalem materials&lt;/a&gt;			for learning CPU internals, because internal Intel HAS and MAS materials were too low-level and hard to dig in to for
			unexperienced hardware engineer, while&amp;nbsp; David Kanter’s articles has explained very well internals of Nehalem architecture
			in very clear, human readable fashion.&lt;/p&gt;
	&lt;/div&gt;
&lt;/div&gt;</content><author><name>Timur Safin</name></author><summary type="html">Several years ago everyone got mad&amp;nbsp;about BigData – nobody knew when smallish data will become BIGDATA, but all knows that it’s trendy and the way to go. Time passed, BigData is not a buzz anymore (most of us missed the moment when Gartner has removed BigData term from their 2016 buzzword 2016 curve http://www.kdnuggets.com/2015/08/gartner-2015-hype-cycle-big-data-is-out-machine-learning-is-in.html), so it’s probably a good time to look back and realize what it is (what it was)…</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature10.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">Remote proxy objects via dynamic dispatch</title><link href="http://tsafin.net/blog/mapreduce/mapreduce-english-remote-proxy/" rel="alternate" type="text/html" title="Remote proxy objects via dynamic dispatch" /><published>2016-07-18T21:00:00+00:00</published><updated>2016-07-18T21:00:00+00:00</updated><id>http://tsafin.net/blog/mapreduce/mapreduce-english-remote-proxy</id><content type="html" xml:base="http://tsafin.net/blog/mapreduce/mapreduce-english-remote-proxy/">&lt;h1 id=&quot;dynamic-dispatch-to-the-rescue&quot;&gt;(Dynamic dispatch to the rescue)&lt;/h1&gt;

&lt;p&gt;This article created as side effect of preparations to the longer set of articles about simple, but still handy MapReduce implementation in Caché. I was looking for relatively easy way to pass arguments to (potentially) multiple targets via remote calling facilities. And after several attempts I have realized that we do have very powerful mechanism in the Caché ObjectScript which might be of particular help here – dynamic dispatch for methods and properties.&lt;/p&gt;

&lt;p&gt;Since Caché 5.2 there are multiple predefined methods inherited by any object based on &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=ENSLIB&amp;amp;CLASSNAME=%25RegisteredObject&quot;&gt;%RegisteredObject&lt;/a&gt; (at the moment they are established in &lt;a href=&quot;http://docs.intersystems.com/latest/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=ENSLIB&amp;amp;CLASSNAME=%25Library.SystemBase&quot;&gt;%Library.SystemBase&lt;/a&gt;) and which are called if there is unknown method or property call, for the name not defined in the class metadata.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchMethod (Method As %String, Args...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Unknown method call or access to unknown multidimensional property (their syntax is identical)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassMethod %DispatchClassMethod (Class As %String, Method As %String, Args...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Unknown classmethod call for the given class&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchGetProperty (Property As %String)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Getter for access to an unknown property&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetProperty (Property As %String, Val)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Setter for an unknown property&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetMultidimProperty (Property As %String, Val, Subs...)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Setter for an unknown multidimensional property (&lt;em&gt;not used in this story&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchGetModified (Property As %String)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Get “modified” flag value for an unknown property (&lt;em&gt;not used in this story&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Method %DispatchSetModified (Property As %String, Val)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Set “modified” flag value for an unknown property(&lt;em&gt;not used in this story&lt;/em&gt;)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;For simplicity sake, we will use only unknown method calls and access to unknown properties, but for the product grade systems, you might eventually override all mentioned methods.&lt;/p&gt;

&lt;h2 id=&quot;logging-proxy-sample&quot;&gt;Logging proxy sample&lt;/h2&gt;

&lt;p&gt;There is good example of dynamic dispatch methods usage in the CACHELIB, and it is called &lt;a href=&quot;http://docs.intersystems.com/cache20161/csp/documatic/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25SYS&amp;amp;CLASSNAME=%25ZEN.proxyObject&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ZEN.proxyObject&lt;/code&gt;&lt;/a&gt;, historically it allowed to operate dynamic properties, even at the times when there was no DocumentDB API and there was no native JSON support in the kernel.&lt;/p&gt;

&lt;p&gt;While still approaching our long-term goal (remote proxy object implementation), let's experiment with something simpler, i.e. to create &quot;logging proxy&quot;, where we will wrap any access to the particular object API using dynamic dispatch methods, while logging each event. [Actually, this provides side effect similar to mocking techniques used in other language environments].&lt;/p&gt;

&lt;p&gt;Let assume we have rudimentary Person class known as &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.SimplePerson&lt;/code&gt; (due to some rare incident, which is very similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.Person&lt;/code&gt; from the SAMPLES namespace :wink: )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:15:23:32:MAPREDUCE&amp;gt;set p = ##class(Sample.SimplePerson).%OpenId(2)

DEVLATEST:15:23:34:MAPREDUCE&amp;gt;zw p

p=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.SimplePerson]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.SimplePerson
|           %%OID: $lb(&quot;2&quot;,&quot;Sample.SimplePerson&quot;)
| reference count: 2
+----------------- attribute values ------------------
|       %Concurrency = 1  &amp;lt;Set&amp;gt;
|                Age = 9
|           Contacts = 23
|               Name = &quot;Waal,Nataliya Q.&quot;
+-----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let's wrap access to this object properties to the logging class instance, and each access to property or method call will write to the logging global somewhere.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// simple sample of a logging proxy object:
/// each access (via call or property access) will 
/// be logged to the designated global
Class Sample.LoggingProxy Extends %RegisteredObject
{
/// log access log to this global
Parameter LoggingGlobal As %String = &quot;^Sample.LoggingProxy&quot;;
/// keep openedobject for the proxy access later
Property OpenedObject As %RegisteredObject;

/// generic log utility, which save new string as a next global entry
ClassMethod Log(Value As %String)
{
    #dim gloRef = ..#LoggingGlobal
    set @gloRef@($increment(@gloRef)) = Value
}

/// more convenient log method for writing prefix (i.e. method name)
/// and arguments we were called in
ClassMethod LogArgs(prefix As %String, args...)
{
    #dim S as %String = $get(prefix) _ &quot;: &quot; _ $get(args(1))
    #dim i as %Integer
    for i=2:1:$get(args) {
        set S = S_&quot;,&quot;_args(i)
    }
    do ..Log(S)
}

/// open instance of a different class using given %ID
ClassMethod %CreateInstance(className As %String, %ID As %String) As Sample.LoggingProxy
{
    #dim wrapper = ..%New()
    set wrapper.OpenedObject = $classmethod(className, &quot;%OpenId&quot;, %ID)
    return wrapper
}

/// log arguments and then dispatch dynamically method to the proxy object
Method %DispatchMethod(methodName As %String, args...)
{
    do ..LogArgs(methodName, args...)
    return $method(..OpenedObject, methodName, args...)
}

/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchGetProperty(Property As %String)
{
    #dim Value as %String = $property(..OpenedObject, Property)
    do ..LogArgs(Property, Value)
    return Value
}

/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchSetProperty(Property, Value As %String)
{
    do ..LogArgs(Property, Value)
    set $property(..OpenedObject, Property) = Value
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;There is class parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;#LoggingGlobal&lt;/code&gt; which defines where we store our log (&lt;code class=&quot;highlighter-rouge&quot;&gt;^Sample.LogginGlobal&lt;/code&gt; in this case);&lt;/li&gt;
  &lt;li&gt;There are simple &lt;code class=&quot;highlighter-rouge&quot;&gt;Log(Arg)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;LogArgs(prefix, args...)&lt;/code&gt; methods which allow conveniently write to this global passed argument or list of them;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchMethod&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchGetProperty&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchSetProperty&lt;/code&gt; handle their respective parts of unknown method call or unknown property access. They log each access event via &lt;code class=&quot;highlighter-rouge&quot;&gt;LogArgs&lt;/code&gt; method, then directly call the wrapped object (&lt;code class=&quot;highlighter-rouge&quot;&gt;..%OpenedObject&lt;/code&gt;) methods or access properties;&lt;/li&gt;
  &lt;li&gt;And there is the “factory method” &lt;code class=&quot;highlighter-rouge&quot;&gt;%CreateInstance&lt;/code&gt; which is opening instance of an asked classname given their instance &lt;code class=&quot;highlighter-rouge&quot;&gt;%ID&lt;/code&gt;. The created object is “wrapped” to the Sample.LogginProxy object, reference to which is returned from this classmethod.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;picture-of-wrapped-object&quot;&gt;picture of wrapped object&lt;/h3&gt;

&lt;p&gt;There is nothing super fancy so far, only 70 lines of simple Caché ObjectScript code, which introduce an idiom of method/property calls with side-effect. Please see how it works in real life:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:15:25:11:MAPREDUCE&amp;gt;set w = ##class(Sample.LoggingProxy).%CreateInstance(&quot;Sample.SimplePerson&quot;, 2)

DEVLATEST:15:25:32:MAPREDUCE&amp;gt;zw w

w=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.LoggingProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.LoggingProxy
| reference count: 2
+----------------- attribute values ------------------
|           (none)
+----------------- swizzled references ---------------
|     i%OpenedObject = &quot;&quot;
|     r%OpenedObject = [2@Sample.SimplePerson](mailto:2@MR.Sample.AgeAverage.Person)
+-----------------------------------------------------

DEVLATEST:15:25:34:MAPREDUCE&amp;gt;w w.Age

9

DEVLATEST:15:25:41:MAPREDUCE&amp;gt;w w.Contacts

23

DEVLATEST:15:25:49:MAPREDUCE&amp;gt;w w.Name

Waal,Nataliya Q.

DEVLATEST:15:26:16:MAPREDUCE&amp;gt;zw ^Sample.LoggingProxy

^Sample.LoggingProxy=4
^Sample.LoggingProxy(1)=&quot;Age: 9&quot;
^Sample.LoggingProxy(2)=&quot;Contacts: 23&quot;
^Sample.LoggingProxy(3)=&quot;Name: Waal,Nataliya Q.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you compare results to the direct access of an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.SimplePerson&lt;/code&gt; above then you'll see that results are quite consistent and as expected.&lt;/p&gt;

&lt;h2 id=&quot;remote-proxy&quot;&gt;Remote proxy&lt;/h2&gt;

&lt;p&gt;Careful reader should still remember, all this stuff we needed just to have easier way for remote proxy objects. But what was wrong with the normal way, using &lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25sys&amp;amp;CLASSNAME=%25Net.RemoteConnection&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Many things (though “deprecated” status of this class is not in this list ).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.intersystems.com/latest/csp/docbook/%25CSP.Documatic.cls?PAGE=CLASS&amp;amp;LIBRARY=%25sys&amp;amp;CLASSNAME=%25Net.RemoteConnection&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt;&lt;/a&gt; is using c-binding facilities (which are wrapper around cpp-binding service) for calling methods from remote Caché instances. If you know its address, target namespace, and you are able to login then you have pretty much all to establish remote procedure call to this Caché node. The problem with this API – it's not the easiest and, certainly, not the least verbose way to use:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class MR.Sample.TestRemoteConnection Extends %RegisteredObject
{

ClassMethod TestMethod(Arg As %String) As %String
{
    quit $zu(5)_&quot;^&quot;_##class(%SYS.System).GetInstanceName()_&quot;^&quot;_
         $i(^MR.Sample.TestRemoteConnectionD)
}

ClassMethod TestLocal()
{
    #dim connection As %Net.RemoteConnection = ##class(%Net.RemoteConnection).%New()
    #dim status As %Status = connection.Connect(&quot;127.0.0.1&quot;,$zu(5),^%SYS(&quot;SSPort&quot;),&quot;_SYSTEM&quot;,&quot;SYS&quot;)
    set status = connection.ResetArguments()
    set status = connection.AddArgument(&quot;Hello&quot;, 0 /*by ref*/, $$$cbindStringId)
    #dim rVal As %String = &quot;&quot;
    set status = connection.InvokeClassMethod(..%ClassName(1), &quot;TestMethod&quot;, .rVal, 1 /*has return*/, $$$cbindStringId)
    zw rVal
    do connection.Disconnect()
}

...

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;i.e. after establishing connection, and before calling classmethod or object instance method, you supposed to prepare a list of arguments of this call (starting from ResetArguments, and then adding next argument via AddArgument, which in turn should take care about proper cpp-binding type information of an argument, its in/out direction, and many other things).&lt;/p&gt;

&lt;p&gt;Also, for me, it was quite annoying to not have simpler way to retrieve return value from other side, because all invocations will give me just execution status code instead, and passing returning value elsewhere in the argument list of the method.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I am too old and am too lazy for that shit!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I want to have less verbose, more convenient way to pass argument to the functions. Remember, we have &lt;code class=&quot;highlighter-rouge&quot;&gt;args...&lt;/code&gt; facilities in the language syntax (for passing variable number of arguments to the function), why simply not to use it for wrapping all the dirty details?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// sample of a remote proxy using %Net.RemoteConnection
Class Sample.RemoteProxy Extends %RegisteredObject
{
Property RemoteConnection As %Net.RemoteConnection [Internal ];
Property LastStatus As %Status [InitialExpression = {$$$OK}];

Method %OnNew() As %Status
{
    set ..RemoteConnection = ##class(%Net.RemoteConnection).%New()

    return $$$OK
}

/// create new instance of a given class name
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%CreateInstance(className)
}

Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%OpenObjectId(className, Id)
}

/// pass the configuration object { &amp;amp;quot;IP&amp;amp;quot;: IP, &amp;amp;quot;Namespace&amp;amp;quot; : Namespace, ... }
Method %Connect(Config As %Object) As Sample.RemoteProxy
{
    #dim sIP As %String = Config.IP
    #dim sNamespace As %String = Config.Namespace
    #dim sPort As %String = Config.Port
    #dim sUsername As %String = Config.Username
    #dim sPassword As %String = Config.Password
    #dim sClientIP As %String = Config.ClientIP
    #dim sClientPort As %String = Config.ClientPort
    
    if sIP = &quot;&quot; { set sIP = &quot;127.0.0.1&quot; }
    if sPort = &quot;&quot; { set sPort = ^%SYS(&quot;SSPort&quot;) }
    set ..LastStatus = ..RemoteConnection.Connect(sIP, sNamespace, sPort, 
                                                  sUsername, sPassword, 
                                                  sClientIP, sClientPort)
    
    return $this
}

ClassMethod ApparentlyClassName(CompoundName As %String, Output ClassName As %String, Output MethodName As %String) As %Boolean [Internal ]
{
    #dim returnValue As %Boolean = 0
    
    if $length(CompoundName, &quot;::&quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &quot;::&quot;, 1)
        set MethodName = $piece(CompoundName, &quot;::&quot;, 2, *)

        return 1
    } elseif $length(CompoundName, &quot;'&quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &quot;'&quot;, 1)
        set MethodName = $piece(CompoundName, &quot;'&quot;, 2, *)

        return 1
    }

    return 0
}

/// log arguments and then dispatch dynamically method to the proxy object
Method %DispatchMethod(methodName As %String, args...)
{
    #dim className as %String = &quot;&quot;
    
    if ..ApparentlyClassName(methodName, .className, .methodName) {
        return ..InvokeClassMethod(className, methodName, args...)
    }
    return 1
}

Method InvokeClassMethod(ClassName As %String, MethodName As %String, args...)
{
    #dim returnValue = &quot;&quot;
    #dim i as %Integer
    do ..RemoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = ..RemoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = ..RemoteConnection.InvokeClassMethod(ClassName, MethodName, .returnValue, $quit)
    return returnValue
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;picture-of-wrapped-object-1&quot;&gt;picture of wrapped object&lt;/h3&gt;

&lt;p&gt;1st simplification which I've introduced here – I do not use regular arguments in the &lt;code class=&quot;highlighter-rouge&quot;&gt;%Connect&lt;/code&gt; method, but rather pass dynamic JSON object for configuration. Consider this as syntaxic sugar, and use as named argument idiom in other languages (where named-arguments are usually implemented the similar way, via on-the-fly construction of key-value pairs for the hash-object passed to the function):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:27:18:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})
 
DEVLATEST:16:27:39:MAPREDUCE&amp;gt;zw w
w=&amp;lt;OBJECT REFERENCE&amp;gt;[1@Sample.RemoteProxy]
+----------------- general information ---------------
|      oref value: 1
|      class name: Sample.RemoteProxy
| reference count: 2
+----------------- attribute values ------------------
|         LastStatus = 1
+----------------- swizzled references ---------------
|           i%Config = &quot;&quot;
|           r%Config = &quot;&quot;
| i%RemoteConnection = &quot;&quot;
| r%RemoteConnection = 2@%Net.RemoteConnection
+-----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is yet another idiom used – wherever possible, I return $this instance reference as returning value, thus it becomes possible to apply &quot;chaining&quot; for method calls. Which is also helping us to reduce a number of code we have to write. [Yes, I'm that lazy!]&lt;/p&gt;

&lt;h3 id=&quot;class-method-call-problem&quot;&gt;Class method call problem&lt;/h3&gt;

&lt;p&gt;This root %Net.RemoteConnection wrapper object could not do much, if there is no place in the context to store references to the created instances. [We will address this problem later, in the different class] The only thing we could do now – is somehow simplify class-method calls, which might be called without object context. We could redefine &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchClassMethod&lt;/code&gt; here, but it will not help us if we want to have &lt;em&gt;generic&lt;/em&gt; remote proxy wrapper [and we do want], which will serve us for any remote class. [Though, it may help if you have 1:1 relationship and some specialized local class as wrapper for some particular remote class] Thus, for the generic case like here, we need something different, but, hopefully, still be as much convenient as possible. InvokeClassMethod implementation above is generally ok, but not as handy as it might be possible. We will try to introduce something more elegant soon.&lt;/p&gt;

&lt;p&gt;But, before then, let us look in what could be written as a method or property identifier. It's not well known fact (at least is not very spread inside of English-based community) that ObjectScript method names could be anything what is considered alphanumeric symbols for the given Caché locale (i.e. it could be not only A-Za-z0-9 for Latin-based locale, but also could be any other “alphabetic” symbol, like А-Яа-я for Russian locales). [&lt;a href=&quot;http://stackoverflow.com/questions/35452352/what-characters-are-usable-in-a-variable-name-in-objectscript-on-a-unicode-ins/35492721#35492721&quot;&gt;see this StackOverflow discussion&lt;/a&gt;] We could even use emoji symbols as inner identifier separator, if we would manage to create such Caché locale. However, in general, any locale specific trick would not fly well, as a generic solution, so we not spend much time here.&lt;/p&gt;

&lt;p&gt;On the other hand, the idea of using special separator inside of method name looks fruitful. We may handle separator in the &lt;code class=&quot;highlighter-rouge&quot;&gt;%DispatchMethod&lt;/code&gt; call, which then will extract class-name encoded and will dispatch to the corresponding class-method function elsewhere.&lt;/p&gt;

&lt;p&gt;So returning to the syntax of allowed method names, it is even less known fact that you could put pretty much &lt;em&gt;everything&lt;/em&gt; to the method or property name if you properly quote them. For example, I want to call LogicalToDisplay classmethod in the class Cinema.Duration. The syntax would be:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:27:41:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})

DEVLATEST:16:51:39:MAPREDUCE&amp;gt;write w.&quot;Cinema.Duration::LogicalToDisplay&quot;(200)

3h20m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Simple and elegant, isn't it?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[This special processing of a method name is done in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ApparentlyClassName&lt;/code&gt; function, where we are looking for “::” (double colon, like in C++) or “’” (single quote, like in Ada or original Perl) as a separator between classname and methodname.]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But please take into consideration, that if you want to call class-method which outputs something to the screen then you are out of luck: cpp-binding protocol will not transfer you back output to the screen, it's not redirected. It returns values, not side-effects.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:16:51:47:MAPREDUCE&amp;gt;do w.&quot;Sample.Person::PrintPersons&quot;(1)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;remote-instances-proxies&quot;&gt;Remote instances proxies&lt;/h3&gt;

&lt;p&gt;As you might recognize in the Sample.RemoteProxy above, we didn't do much there, only establish connection and call class methods. However, for creation of a remote instance wrapper (&lt;code class=&quot;highlighter-rouge&quot;&gt;%CreateInstance&lt;/code&gt;) and for opening remote instance by %ID (&lt;code class=&quot;highlighter-rouge&quot;&gt;%OpenObjectId&lt;/code&gt;) we use another class facilities – that is responsibility of a &lt;code class=&quot;highlighter-rouge&quot;&gt;%Sample.RemoteProxy.Object&lt;/code&gt; wrapper class.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class Sample.RemoteProxy.Object Extends %RegisteredObject
{
/// keep openedobject for the proxy access later
Property OpenedObject As %Binary;
Property Owner As Sample.RemoteProxy [ Internal ];
Property LastStatus As %Status [ InitialExpression = {$$$OK}, Internal ];

Method RemoteConnection() As %Net.RemoteConnection [ CodeMode = expression ]
{
..Owner.RemoteConnection
}

Method %OnNew(owner As Sample.RemoteProxy) As %Status
{
    set ..Owner = owner
    return $$$OK
}

/// open instance of a different class using given %ID
Method %CreateInstance(className As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().CreateInstance(className, .pObject)
    set ..OpenedObject = &quot;&quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

/// open instance of a different class using given %ID
Method %OpenObjectId(className As %String, Id As %String) As Sample.RemoteProxy.Object
{
    #dim pObject As %RegisteredObject = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().OpenObjectId(className, Id, .pObject)
    set ..OpenedObject = &quot;&quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
}

Method InvokeMethod(MethodName As %String, args...) [ Internal ]
{
    #dim returnValue = &quot;&quot;
    #dim i as %Integer
    #dim remoteConnection = ..RemoteConnection()
    do remoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = remoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = remoteConnection.InvokeInstanceMethod(..OpenedObject, MethodName, .returnValue, $quit)
    return returnValue
}

/// log arguments and then dispatch dynamically method to the proxy object
Method %DispatchMethod(methodName As %String, args...)
{
    //do ..LogArgs(methodName, args...)
    return ..InvokeMethod(methodName, args...)
}

/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchGetProperty(Property As %String)
{
    #dim value = &quot;&quot;
    set ..LastStatus = ..RemoteConnection().GetProperty(..OpenedObject, Property, .value)
    return value
}

/// log arguments and then dispatch dynamically property access to the proxy object
Method %DispatchSetProperty(Property, Value As %String) As %Status
{
   set ..LastStatus = ..RemoteConnection().SetProperty(..OpenedObject, Property, Value)
    return ..LastStatus
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is common connection object, which &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy&lt;/code&gt; used, but many remote object instances &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.RemoteProxy.Object&lt;/code&gt;, each of which should get access to the remote connection via their &lt;code class=&quot;highlighter-rouge&quot;&gt;..Owner&lt;/code&gt; reference passed at the initialization time (see &lt;code class=&quot;highlighter-rouge&quot;&gt;%OnNew&lt;/code&gt; argument passed).&lt;/p&gt;

&lt;p&gt;There is relatively convenient InvokeMethod created, which handles method calls with any number of arguments, and which marshalls  arguments to the corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;%Net.RemoteConnection&lt;/code&gt; calls (i.e. call &lt;code class=&quot;highlighter-rouge&quot;&gt;ResetArguments&lt;/code&gt; and many &lt;code class=&quot;highlighter-rouge&quot;&gt;AddArgument&lt;/code&gt;), and which then calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;%NetRemoteConnection::InvokeInstanceMethod&lt;/code&gt; for actual method execution, processing their return value.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEVLATEST:19:23:54:MAPREDUCE&amp;gt;set w = ##class(Sample.RemoteProxy).%New().%Connect({&quot;Namespace&quot;:&quot;SAMPLES&quot;, &quot;Username&quot;:&quot;\_SYSTEM&quot;, &quot;Password&quot;:&quot;SYS&quot;})

…

DEVLATEST:19:23:56:MAPREDUCE&amp;gt;set p = w.%OpenObjectId(&quot;Sample.Person&quot;,1)

DEVLATEST:19:24:05:MAPREDUCE&amp;gt;write p.Name

Quince,Maria B.

DEVLATEST:19:24:11:MAPREDUCE&amp;gt;write p.SSN

369-27-1697

DEVLATEST:19:24:17:MAPREDUCE&amp;gt;write p.Addition(1,2)

3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this code above, we instantiate remote proxy to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Sample.Person&lt;/code&gt; instance from &lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLES&lt;/code&gt; namespace. And then call its method(s) or access properties. Is it simple enough?&lt;/p&gt;

&lt;h3 id=&quot;kind-of-conclusion&quot;&gt;Kind of conclusion&lt;/h3&gt;

&lt;p&gt;This is not yet product quality code: there is no proper handling of errors (they should be raising exceptions if there is something wrong happen), there is no handling of disconnect or whole objects shutdown, but even today this set of classes show how remote proxy could be used in the readable and maintainable code. Which worth all efforts.&lt;/p&gt;

&lt;p&gt;All the code mentioned in the article is available via this &lt;a href=&quot;https://gist.github.com/tsafin/02bb6b5967cbdd1176618cb645445770&quot;&gt;gist&lt;/a&gt;.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;Export generator=&amp;quot;Cache&amp;quot; version=&amp;quot;25&amp;quot; zv=&amp;quot;Cache for Windows (x86-64) 2016.4 (Build 555U JAVAINTEG)&amp;quot; ts=&amp;quot;2016-07-18 15:27:06&amp;quot;&amp;gt;
&amp;lt;Class name=&amp;quot;Sample.LoggingProxy&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
simple sample of a logging proxy object:
each access (via call or property access) will 
be logged to the designated global&amp;lt;/Description&amp;gt;
&amp;lt;Super&amp;gt;%RegisteredObject&amp;lt;/Super&amp;gt;
&amp;lt;TimeChanged&amp;gt;64116,57644.95789&amp;lt;/TimeChanged&amp;gt;
&amp;lt;TimeCreated&amp;gt;64110,60845.71095&amp;lt;/TimeCreated&amp;gt;

&amp;lt;Parameter name=&amp;quot;LoggingGlobal&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log access log to this global&amp;lt;/Description&amp;gt;
&amp;lt;Type&amp;gt;%String&amp;lt;/Type&amp;gt;
&amp;lt;Default&amp;gt;^Sample.LoggingProxy&amp;lt;/Default&amp;gt;
&amp;lt;/Parameter&amp;gt;

&amp;lt;Property name=&amp;quot;OpenedObject&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
keep openedobject for the proxy access later&amp;lt;/Description&amp;gt;
&amp;lt;Type&amp;gt;%RegisteredObject&amp;lt;/Type&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Method name=&amp;quot;Log&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
generic log utility, which save new string as a next global entry&amp;lt;/Description&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;FormalSpec&amp;gt;Value:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim gloRef = ..#LoggingGlobal
    set @gloRef@($increment(@gloRef)) = Value
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;LogArgs&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
more convenient log method for writing prefix (i.e. method name)
and arguments we were called in&amp;lt;/Description&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;FormalSpec&amp;gt;prefix:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim S as %String = $get(prefix) _ &amp;quot;: &amp;quot; _ $get(args(1))
    #dim i as %Integer
    for i=2:1:$get(args) {
        set S = S_&amp;quot;,&amp;quot;_args(i)
    }
    do ..Log(S)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%CreateInstance&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
open instance of a different class using given %ID&amp;lt;/Description&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String,%ID:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.LoggingProxy&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim wrapper = ..%New()
    set wrapper.OpenedObject = $classmethod(className, &amp;quot;%OpenId&amp;quot;, %ID)
    return wrapper
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchMethod&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically method to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;methodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    do ..LogArgs(methodName, args...)
    return $method(..OpenedObject, methodName, args...)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchClassMethod&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically class-method to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String,methodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    do ..LogArgs(className_&amp;quot;::&amp;quot;_methodName, args...)
    return $classmethod(className, methodName, args...) // FIXME - FRAMESTACK
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchGetProperty&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically property access to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;Property:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim Value as %String = $property(..OpenedObject, Property)
    do ..LogArgs(Property, Value)
    return Value
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchSetProperty&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically property access to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;Property,Value:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    do ..LogArgs(Property, Value)
    set $property(..OpenedObject, Property) = Value
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;
&amp;lt;/Class&amp;gt;


&amp;lt;Class name=&amp;quot;Sample.RemoteProxy.Object&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
sample of a remote proxy using %Net.RemoteConnection&amp;lt;/Description&amp;gt;
&amp;lt;Super&amp;gt;%RegisteredObject&amp;lt;/Super&amp;gt;
&amp;lt;TimeChanged&amp;gt;64116,9199.418879&amp;lt;/TimeChanged&amp;gt;
&amp;lt;TimeCreated&amp;gt;64115,83996.532254&amp;lt;/TimeCreated&amp;gt;

&amp;lt;Property name=&amp;quot;OpenedObject&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
keep openedobject for the proxy access later&amp;lt;/Description&amp;gt;
&amp;lt;Type&amp;gt;%Binary&amp;lt;/Type&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;Owner&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;Sample.RemoteProxy&amp;lt;/Type&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;LastStatus&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Status&amp;lt;/Type&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;InitialExpression&amp;gt;$$$OK&amp;lt;/InitialExpression&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Method name=&amp;quot;RemoteConnection&amp;quot;&amp;gt;
&amp;lt;CodeMode&amp;gt;expression&amp;lt;/CodeMode&amp;gt;
&amp;lt;ReturnType&amp;gt;%Net.RemoteConnection&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[..Owner.RemoteConnection
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%OnNew&amp;quot;&amp;gt;
&amp;lt;FormalSpec&amp;gt;owner:Sample.RemoteProxy&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;%Status&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    set ..Owner = owner
    
    return $$$OK
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%CreateInstance&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
open instance of a different class using given %ID&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.RemoteProxy.Object&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim pObject As %RegisteredObject = &amp;quot;&amp;quot;
    set ..LastStatus = ..RemoteConnection().CreateInstance(className, .pObject)
    set ..OpenedObject = &amp;quot;&amp;quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%OpenObjectId&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
open instance of a different class using given %ID&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String,Id:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.RemoteProxy.Object&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim pObject As %RegisteredObject = &amp;quot;&amp;quot;
    set ..LastStatus = ..RemoteConnection().OpenObjectId(className, Id, .pObject)
    set ..OpenedObject = &amp;quot;&amp;quot;
    if $$$ISOK(..LastStatus) {
        set ..OpenedObject = pObject
    }
    return $this
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;InvokeMethod&amp;quot;&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;FormalSpec&amp;gt;MethodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim returnValue = &amp;quot;&amp;quot;
    #dim i as %Integer
    #dim remoteConnection = ..RemoteConnection()
    do remoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = remoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = remoteConnection.InvokeInstanceMethod(..OpenedObject, MethodName, .returnValue, $quit)
    return returnValue
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchMethod&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically method to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;methodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    //do ..LogArgs(methodName, args...)
    return ..InvokeMethod(methodName, args...)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;UDLText name=&amp;quot;T&amp;quot;&amp;gt;
&amp;lt;Content&amp;gt;&amp;lt;![CDATA[
/* /// log arguments and then dispatch dynamically class-method to the proxy object
ClassMethod %DispatchClassMethod(className As %String, methodName As %String, args...)
{
    //do ..LogArgs(className_&amp;quot;::&amp;quot;_methodName, args...)
    return $classmethod(className, methodName, args...) // FIXME - FRAMESTACK
}
*/
]]&amp;gt;&amp;lt;/Content&amp;gt;
&amp;lt;/UDLText&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchGetProperty&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically property access to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;Property:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    //do ..LogArgs(Property, Value)

    #dim value = &amp;quot;&amp;quot;
    set ..LastStatus = ..RemoteConnection().GetProperty(..OpenedObject, Property, .value)
    return value
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchSetProperty&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically property access to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;Property,Value:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;%Status&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    //do ..LogArgs(Property, Value)
    set ..LastStatus = ..RemoteConnection().SetProperty(..OpenedObject, Property, Value)
    return ..LastStatus
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;
&amp;lt;/Class&amp;gt;


&amp;lt;Class name=&amp;quot;Sample.RemoteProxy&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
sample of a remote proxy using %Net.RemoteConnection&amp;lt;/Description&amp;gt;
&amp;lt;Super&amp;gt;%RegisteredObject&amp;lt;/Super&amp;gt;
&amp;lt;TimeChanged&amp;gt;64117,53069.639231&amp;lt;/TimeChanged&amp;gt;
&amp;lt;TimeCreated&amp;gt;64112,53523.232695&amp;lt;/TimeCreated&amp;gt;

&amp;lt;Property name=&amp;quot;Config&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Object&amp;lt;/Type&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;RemoteConnection&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Net.RemoteConnection&amp;lt;/Type&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;LastStatus&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Status&amp;lt;/Type&amp;gt;
&amp;lt;InitialExpression&amp;gt;$$$OK&amp;lt;/InitialExpression&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Method name=&amp;quot;%OnNew&amp;quot;&amp;gt;
&amp;lt;FormalSpec&amp;gt;initval&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;%Status&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim retValue As %Status = $$$OK
    
    set ..RemoteConnection = ##class(%Net.RemoteConnection).%New()
    
    return retValue
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%CreateInstance&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
create new instance of a given class name&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.RemoteProxy.Object&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%CreateInstance(className)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%OpenObjectId&amp;quot;&amp;gt;
&amp;lt;FormalSpec&amp;gt;className:%String,Id:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.RemoteProxy.Object&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim instanceProxy As Sample.RemoteProxy.Object = ##class(Sample.RemoteProxy.Object).%New($this)
    return instanceProxy.%OpenObjectId(className, Id)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;Debug&amp;quot;&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    set w = ##class(Sample.RemoteProxy).%New().%Connect({&amp;quot;Namespace&amp;quot;:&amp;quot;SAMPLES&amp;quot;, &amp;quot;Username&amp;quot;:&amp;quot;_SYSTEM&amp;quot;, &amp;quot;Password&amp;quot;:&amp;quot;SYS&amp;quot;})
    //do w.&amp;quot;Sample.Person::PrintPersons&amp;quot;(1)
    write w.&amp;quot;Cinema.Duration::LogicalToDisplay&amp;quot;(200)
    set p = w.%OpenObjectId(&amp;quot;Sample.Person&amp;quot;,1)
    write p.Name
    write p.SSN
    write p.Addition(1,2)
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%Connect&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
pass the configuration object { &amp;quot;IP&amp;quot;: IP, &amp;quot;Namespace&amp;quot; : Namespace, ... }&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;Config:%Object&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;Sample.RemoteProxy&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim sIP As %String = Config.IP
    #dim sNamespace As %String = Config.Namespace
    #dim sPort As %String = Config.Port
    #dim sUsername As %String = Config.Username
    #dim sPassword As %String = Config.Password
    #dim sClientIP As %String = Config.ClientIP
    #dim sClientPort As %String = Config.ClientPort
    
    if sIP = &amp;quot;&amp;quot; {
        set sIP = &amp;quot;127.0.0.1&amp;quot;
    }
    if sPort = &amp;quot;&amp;quot; {
        set sPort = ^%SYS(&amp;quot;SSPort&amp;quot;)
    }
    set ..LastStatus = ..RemoteConnection.Connect(sIP, sNamespace, sPort, 
                                                  sUsername, sPassword, 
                                                  sClientIP, sClientPort)
    
    return $this
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;ApparentlyClassName&amp;quot;&amp;gt;
&amp;lt;Internal&amp;gt;1&amp;lt;/Internal&amp;gt;
&amp;lt;ClassMethod&amp;gt;1&amp;lt;/ClassMethod&amp;gt;
&amp;lt;FormalSpec&amp;gt;CompoundName:%String,*ClassName:%String,*MethodName:%String&amp;lt;/FormalSpec&amp;gt;
&amp;lt;ReturnType&amp;gt;%Boolean&amp;lt;/ReturnType&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim returnValue As %Boolean = 0
    
    if $length(CompoundName, &amp;quot;::&amp;quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &amp;quot;::&amp;quot;, 1)
        set MethodName = $piece(CompoundName, &amp;quot;::&amp;quot;, 2, *)

        return 1
    } elseif $length(CompoundName, &amp;quot;&amp;#39;&amp;quot;) &amp;gt; 1 {
        set ClassName = $piece(CompoundName, &amp;quot;&amp;#39;&amp;quot;, 1)
        set MethodName = $piece(CompoundName, &amp;quot;&amp;#39;&amp;quot;, 2, *)

        return 1
    }

    return 0
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;%DispatchMethod&amp;quot;&amp;gt;
&amp;lt;Description&amp;gt;
log arguments and then dispatch dynamically method to the proxy object&amp;lt;/Description&amp;gt;
&amp;lt;FormalSpec&amp;gt;methodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    //do ..LogArgs(methodName, args...)
    #dim className as %String = &amp;quot;&amp;quot;
    
    if ..ApparentlyClassName(methodName, .className, .methodName) {
        return ..InvokeClassMethod(className, methodName, args...)
    }
    return 1 ;$method(..OpenedObject, methodName, args...) // FIXME - no way to get here
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;

&amp;lt;Method name=&amp;quot;InvokeClassMethod&amp;quot;&amp;gt;
&amp;lt;FormalSpec&amp;gt;ClassName:%String,MethodName:%String,args...&amp;lt;/FormalSpec&amp;gt;
&amp;lt;Implementation&amp;gt;&amp;lt;![CDATA[
    #dim returnValue = &amp;quot;&amp;quot;
    #dim i as %Integer
    do ..RemoteConnection.ResetArguments()
    for i=1:1:$get(args) {
        set ..LastStatus = ..RemoteConnection.AddArgument(args(i), 0)
    }
    set ..LastStatus = ..RemoteConnection.InvokeClassMethod(ClassName, MethodName, .returnValue, $quit)
    return returnValue
]]&amp;gt;&amp;lt;/Implementation&amp;gt;
&amp;lt;/Method&amp;gt;
&amp;lt;/Class&amp;gt;


&amp;lt;Class name=&amp;quot;Sample.SimplePerson&amp;quot;&amp;gt;
&amp;lt;Super&amp;gt;%Persistent,%Populate&amp;lt;/Super&amp;gt;
&amp;lt;TimeChanged&amp;gt;64117,55447.475066&amp;lt;/TimeChanged&amp;gt;
&amp;lt;TimeCreated&amp;gt;64117,55407.005491&amp;lt;/TimeCreated&amp;gt;

&amp;lt;Property name=&amp;quot;Name&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%String&amp;lt;/Type&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;Age&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Integer&amp;lt;/Type&amp;gt;
&amp;lt;Parameter name=&amp;quot;MAXVAL&amp;quot; value=&amp;quot;100&amp;quot;/&amp;gt;
&amp;lt;Parameter name=&amp;quot;MINVAL&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Property name=&amp;quot;Contacts&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Integer&amp;lt;/Type&amp;gt;
&amp;lt;Parameter name=&amp;quot;MAXVAL&amp;quot; value=&amp;quot;40&amp;quot;/&amp;gt;
&amp;lt;Parameter name=&amp;quot;MINVAL&amp;quot; value=&amp;quot;0&amp;quot;/&amp;gt;
&amp;lt;/Property&amp;gt;

&amp;lt;Storage name=&amp;quot;Default&amp;quot;&amp;gt;
&amp;lt;Type&amp;gt;%Library.CacheStorage&amp;lt;/Type&amp;gt;
&amp;lt;DataLocation&amp;gt;^Sample.SimplePersonD&amp;lt;/DataLocation&amp;gt;
&amp;lt;DefaultData&amp;gt;SimplePersonDefaultData&amp;lt;/DefaultData&amp;gt;
&amp;lt;IdLocation&amp;gt;^Sample.SimplePersonD&amp;lt;/IdLocation&amp;gt;
&amp;lt;IndexLocation&amp;gt;^Sample.SimplePersonI&amp;lt;/IndexLocation&amp;gt;
&amp;lt;StreamLocation&amp;gt;^Sample.SimplePersonS&amp;lt;/StreamLocation&amp;gt;
&amp;lt;ExtentSize&amp;gt;1000&amp;lt;/ExtentSize&amp;gt;
&amp;lt;Data name=&amp;quot;SimplePersonDefaultData&amp;quot;&amp;gt;
&amp;lt;Structure&amp;gt;listnode&amp;lt;/Structure&amp;gt;
&amp;lt;Subscript/&amp;gt;
&amp;lt;Value name=&amp;quot;1&amp;quot;&amp;gt;
&amp;lt;Value&amp;gt;%%CLASSNAME&amp;lt;/Value&amp;gt;
&amp;lt;/Value&amp;gt;
&amp;lt;Value name=&amp;quot;2&amp;quot;&amp;gt;
&amp;lt;Value&amp;gt;Name&amp;lt;/Value&amp;gt;
&amp;lt;/Value&amp;gt;
&amp;lt;Value name=&amp;quot;3&amp;quot;&amp;gt;
&amp;lt;Value&amp;gt;Age&amp;lt;/Value&amp;gt;
&amp;lt;/Value&amp;gt;
&amp;lt;Value name=&amp;quot;4&amp;quot;&amp;gt;
&amp;lt;Value&amp;gt;Contacts&amp;lt;/Value&amp;gt;
&amp;lt;/Value&amp;gt;
&amp;lt;/Data&amp;gt;
&amp;lt;Property name=&amp;quot;%%CLASSNAME&amp;quot;&amp;gt;
&amp;lt;Selectivity&amp;gt;0.1000%&amp;lt;/Selectivity&amp;gt;
&amp;lt;OutlierSelectivity&amp;gt;.992632:&amp;lt;/OutlierSelectivity&amp;gt;
&amp;lt;AverageFieldSize&amp;gt;1&amp;lt;/AverageFieldSize&amp;gt;
&amp;lt;/Property&amp;gt;
&amp;lt;Property name=&amp;quot;%%ID&amp;quot;&amp;gt;
&amp;lt;Selectivity&amp;gt;1&amp;lt;/Selectivity&amp;gt;
&amp;lt;AverageFieldSize&amp;gt;2.86&amp;lt;/AverageFieldSize&amp;gt;
&amp;lt;/Property&amp;gt;
&amp;lt;Property name=&amp;quot;Age&amp;quot;&amp;gt;
&amp;lt;Selectivity&amp;gt;1.2399%&amp;lt;/Selectivity&amp;gt;
&amp;lt;AverageFieldSize&amp;gt;1.86&amp;lt;/AverageFieldSize&amp;gt;
&amp;lt;/Property&amp;gt;
&amp;lt;Property name=&amp;quot;Contacts&amp;quot;&amp;gt;
&amp;lt;Selectivity&amp;gt;2.6300%&amp;lt;/Selectivity&amp;gt;
&amp;lt;AverageFieldSize&amp;gt;1.74&amp;lt;/AverageFieldSize&amp;gt;
&amp;lt;/Property&amp;gt;
&amp;lt;Property name=&amp;quot;Name&amp;quot;&amp;gt;
&amp;lt;Selectivity&amp;gt;0.1000%&amp;lt;/Selectivity&amp;gt;
&amp;lt;AverageFieldSize&amp;gt;15.87&amp;lt;/AverageFieldSize&amp;gt;
&amp;lt;/Property&amp;gt;
&amp;lt;SQLMap name=&amp;quot;IDKEY&amp;quot;&amp;gt;
&amp;lt;BlockCount&amp;gt;-20&amp;lt;/BlockCount&amp;gt;
&amp;lt;/SQLMap&amp;gt;
&amp;lt;/Storage&amp;gt;
&amp;lt;/Class&amp;gt;
&amp;lt;/Export&amp;gt;
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/tsafin/02bb6b5967cbdd1176618cb645445770.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;questions&quot;&gt;Questions&lt;/h1&gt;

&lt;h2 id=&quot;_questions-1-why-do-you-use-json-object-instead-of-a-usual-signature&quot;&gt;_Questions 1. Why do you use JSON object instead of a usual signature?&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Method %Connect(IP = &quot;127.0.0.1&quot;, Port = {^%SYS(&quot;SSPort&quot;)}, Namespace = &quot;%SYS&quot;, Username, Password, ClientIP, ClientPort ) As Sample.RemoteProxy

{ }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally, this code can be moved inside of the %OnNew method.&lt;/p&gt;

&lt;h2 id=&quot;answer&quot;&gt;Answer:&lt;/h2&gt;

&lt;p&gt;Because of several reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;I hate long list of arguments passed to function, especially when most of them are optional;&lt;/li&gt;
  &lt;li&gt;In similar cases I prefer to use named-arguments approach, whcih I saw otiginally in Perl (here  &lt;a href=&quot;http://perldesignpatterns.com/?NamedArguments&quot;&gt;is the quick link&lt;/a&gt; &lt;a href=&quot;http://perldesignpatterns.com/?NamedArguments&quot;&gt; &lt;/a&gt;I've found which shows this idiom). Named arguments allow to pass arguments in any order, which allows to avoid many related errors if (optional) argument passed in the worng order.&lt;/li&gt;
  &lt;li&gt;Named-arguments were actually creating hash object in Perl, with which we worked later, accessing it's key-value pairs.&lt;/li&gt;
  &lt;li&gt;But at the end of a day the new, JSON dynamic objects we have in Cache' are semantically equivalent to hash-objects we were operating in Perl in the past;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus similar idiom could be used in the ObjectScript.&lt;/p&gt;

&lt;p&gt;P.S.&lt;/p&gt;

&lt;p&gt;Though I agree, that was some stretching to use this idiom in this particular case, with not that much large number of arguments. But at least it didn't make code less readable. :smile:&lt;/p&gt;

&lt;h2 id=&quot;answer-1&quot;&gt;Answer:&lt;/h2&gt;

&lt;p&gt;Also about comment to move %Connect code inside of %New.&lt;/p&gt;

&lt;p&gt;This is not, generally a good idea to insert potentially long and slow code inside of object constructor. I prefer to have slim and fast %New, which might be nested elsewher to some wrapping onjects. While keeping slow, and expensive functions like %Connect in this case, outside of constructor, independently callable.&lt;/p&gt;

&lt;p&gt;For example, try to use incorrect login details here and then see how long it will take to fail such connection (i.e. timeout period).&lt;/p&gt;

&lt;h2 id=&quot;question-2&quot;&gt;Question 2:&lt;/h2&gt;

&lt;p&gt;You only partially correct:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;yes, as lazy developers we prefer to write only 1 method call, instead of 2 chained together;&lt;/li&gt;
  &lt;li&gt;but, no, this is not %Connect (which may be expensive operation) which should move to the %OnNew, but rather other way around.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I.e. for the cases when we need both (not actually in 100% of a cases, rather 90%) we could create combined classmethod, which will create instance of a class via call to %New() and then will proceed the necessary side-effect. i.e.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ClassMethod %ConnectNew(Config As %Object) As Sample.RemoteProxy { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In general, you should rather avoid creating huge DOM tree of an objects, or proceeding network operations inside of %New constructor. Constructor needs to allocate just bare minimum of memory, necessary for beginning of operations, and initialize fields to their default values [that will be done automatically]. That's it.&lt;/p&gt;</content><author><name></name></author><summary type="html">(Dynamic dispatch to the rescue)</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature2.jpg%22,%20%22credits%22=%3Enil%7D" /></entry><entry><title type="html">InterSystems hackathon 2015 results</title><link href="http://tsafin.net/hackathon/intersystems-hackathon-2015-results-english/" rel="alternate" type="text/html" title="InterSystems hackathon 2015 results" /><published>2015-09-23T12:49:24+00:00</published><updated>2015-09-23T12:49:24+00:00</updated><id>http://tsafin.net/hackathon/intersystems-hackathon-2015-results-english</id><content type="html" xml:base="http://tsafin.net/hackathon/intersystems-hackathon-2015-results-english/">&lt;blockquote&gt;&lt;em&gt;[Русская версия статьи изначально опубликована на &lt;a href=&quot;http://habrahabr.ru/company/intersystems/blog/267459/&quot; target=&quot;_blank&quot;&gt;Хабре здесь&lt;/a&gt;]&lt;/em&gt;&lt;/blockquote&gt;

&lt;p&gt;We have never arranged hackathon before, and none of us has even participated in such events. But if we bring ~50 of experienced COS developers to the same location for multi days training then why not try to apply their expertise for our good? Divide to teams, ask for ideas, and make them code some crazy projects in 1 day of hacking. &lt;em&gt;[Well a little bit less than 1 day as we have found actually, but still idea is the same]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We are newbies in hackathon organization, so we asked for the external help – we have contacted Grigory Petrov (now technical evangelist of Voximplant, and former evangelist of Digital October center where he arranged several hackathon and similar events). He was willing to help, but we have discovered the harder way that he has to be in PyCon 2015 the same days we arrange Russian InterSystems School. Sigh. In any case, after long discussion with Grigory we have got clear understanding of all possible scenarios, of steps we need to proceed before hackathon, during, what to do, when and in which sequence. We were mentally ready for it.&lt;/p&gt;

&lt;p&gt;InterSystems Fall School is usually 2-3 days long event. This year we were planning to start with almost 2 days of technical training and exercises (where most of training were doing various operations over the same dataset – database of sql.ru/cache posts). And after those 2 days participant supposed to be well prepared to use modern practices (using Angular for the client development, DeepSee and iKnow for analytics, and such).&lt;/p&gt;

&lt;p&gt;At around of 17:00 of 2&lt;sup&gt;nd&lt;/sup&gt; day we started hackathon: after brief introduction of rules and planned schedule, we started initial project teams assembly. The plan was  – get all possible ideas for projects from all relevant sources (i.e. our Russian University grants suggested projects, or suggested extension ideas to some already existing GitHub projects), start to discuss them and then choice project from the list, or any other relevant idea (which might be influenced by the list of suggested ideas).&lt;/p&gt;

&lt;!-- &lt;a href=&quot;/assets/team-list.jpg&quot;&gt;&lt;img class=&quot;size-medium wp-image-1917 aligncenter&quot; src=&quot;/assets/team-list-170x300.jpg&quot; alt=&quot;team-list&quot; width=&quot;170&quot; height=&quot;300&quot; /&gt;&lt;/a&gt; --&gt;

&lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card-image&quot;&gt;
      &lt;img src=&quot;/assets/team-list.jpg&quot; alt=&quot;team-list&quot; width=&quot;170&quot; height=&quot;300&quot; /&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- ![team-list](/assets/team-list.jpg) --&gt;

&lt;p&gt;If we review now all projects, which started, and categorize them by their sources, then we see that only small fraction were using topics of the suggested list. Most winners were developing their own idea.&lt;/p&gt;

&lt;p&gt;Here is the list of projects at the start:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;1.       Atom plugin;&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Suggested development of existing project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;2.       CPM web site;&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Suggested development of existing project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;3.       Geo-spatial indices&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Suggested but new&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;4.       Caché &amp;lt;&amp;gt; JS projection&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Brand new&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;5.       Arduino connect&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Suggested but new&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;6.       Call diagram&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Brand new&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;414&quot;&gt;7.       B*-Tree map&lt;/td&gt;
&lt;td width=&quot;736&quot;&gt;Brand new&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We have proceeded a couple of intermediate stops where we have reviewed project advancement (i.e. at around 22:00 the 1&lt;sup&gt;st&lt;/sup&gt; day, and at 11:00 the next day). And we stopped development at the 13:00 the 2&lt;sup&gt;nd&lt;/sup&gt; day (due to logistics constraints), and not as if it would be spanning whole day hacking – the 17:00 the 2&lt;sup&gt;nd&lt;/sup&gt; day. i.e. teams have only 20 hours for development, but apparently it was not a big deal for those who prepared well enough.&lt;/p&gt;

&lt;p&gt;Each team had 5-10 minutes for presentation, and then ISC SEs decided which teams are winners. We have touch problem to choose – there were 4 brilliant works, each of them in other circumstances would be considered a winner. But we decided that Nikita Savchenko/Anton Gnibeda work this day was the best. Just because of astonishing development speed (only 1 day since the project inception) and the shown quality and achieved results.&lt;/p&gt;

&lt;!-- 
&lt;a href=&quot;/assets/hackathon-1.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-1920&quot; src=&quot;/assets/hackathon-1-300x265.jpg&quot; alt=&quot;hackathon-1&quot; width=&quot;159&quot; height=&quot;142&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;/assets/hackathon-2.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-1918&quot; src=&quot;/assets/hackathon-2-300x214.jpg&quot; alt=&quot;hackathon-2&quot; width=&quot;195&quot; height=&quot;142&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;/assets/hackathon-3.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-1919&quot; src=&quot;/assets/hackathon-3-300x254.jpg&quot; alt=&quot;hackathon-3&quot; width=&quot;166&quot; height=&quot;142&quot; /&gt;&lt;/a&gt; --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/hackathon-1.jpg&quot; alt=&quot;hackathon-1&quot; /&gt;&lt;img src=&quot;/assets/hackathon-2.jpg&quot; alt=&quot;hackathon-2&quot; /&gt;&lt;img src=&quot;/assets/hackathon-3.jpg&quot; alt=&quot;hackathon-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here are more details about projects winners:&lt;/p&gt;
&lt;h1&gt;1&lt;sup&gt;st&lt;/sup&gt; place&lt;/h1&gt;
&lt;p&gt;Nikita Svchenko and Anton Gnibeda are stars of our local community. They both participated in many outstanding projects, e.g&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://github.com/ZitRos&quot;&gt;Nikita @ZitRos Savchenko&lt;/a&gt;: LightPivotTable in &lt;a href=&quot;https://github.com/ZitRos/LightPivotTable&quot;&gt;DeepSee Mobile&lt;/a&gt;, &lt;a href=&quot;https://github.com/ZitRos/CacheUMLExplorer&quot;&gt;CacheUMLExplorer&lt;/a&gt;, &lt;a href=&quot;https://github.com/intersystems-ru/webterminal&quot;&gt;WebTerminal&lt;/a&gt;, &lt;a href=&quot;https://github.com/ZitRos/globalsDB-Admin-NodeJS&quot;&gt;GlobalsDB Admin&lt;/a&gt;, etc&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://github.com/gnibeda&quot;&gt;Anton @gnibeda Gnibeda&lt;/a&gt;: &lt;a href=&quot;https://github.com/intersystems-ru/DeepSeeWeb&quot;&gt;DeepSee Web&lt;/a&gt;, &lt;a href=&quot;https://github.com/intersystems-ru/DeepSeeMobile&quot;&gt;DeepSee Mobile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Although Nikita, Anton and Irina are all living in Kiev nowadays, but they usually not working on the same project at the same time, and this school was a rare chance for them to work together. But when they decided to form the team we (organizers) were tending to break a team and rebalance to others because other teams will be lacking of frontend skills we need elsewhere. However, at the end we decided to just see where this star team could go given opportunity and chance. [That was correct decision as we see today]&lt;/p&gt;

&lt;p&gt;This project was not developing some precooked project as many other were doing. They have developed idea at the start of 2&lt;sup&gt;nd&lt;/sup&gt; day of school, and then started coding immediately.&lt;/p&gt;
&lt;h2&gt;JavaScript Object Data Model — JavaScript object projection from Caché&lt;/h2&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;321&quot;&gt;Team:&lt;/td&gt;
&lt;td width=&quot;1017&quot;&gt;&lt;a href=&quot;https://d.docs.live.net/32e0f479b4a6efd5/isc/school-2015/hackathon-isc-schoool-2015.docx&quot;&gt;Nikita @ZitRos Savchenko&lt;/a&gt;, &lt;a href=&quot;https://github.com/gnibeda&quot;&gt;Anton @gnibeda Gnibeda&lt;/a&gt;, &lt;a href=&quot;https://github.com/Gra-ach&quot;&gt;Irene @Gra-ach Mikhailova&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;321&quot;&gt;GitHub repo:&lt;/td&gt;
&lt;td width=&quot;1017&quot;&gt;&lt;a href=&quot;https://github.com/ZitRos/cjs&quot;&gt;https://github.com/ZitRos/cjs&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;There are 2 parts in this projects: server COS and client JavaScript. Server-side is simple REST data-points which allow get access to methods/properties of a classes. Client-side uses dirty JavaScript magic for extending client-side objects with the list of available server-side methods/properties. Which simplify debugging in the debugger&lt;/p&gt;

&lt;!-- &lt;a href=&quot;/assets/cjs-in-browser.jpg&quot;&gt;&lt;img class=&quot;wp-image-1914 aligncenter&quot; src=&quot;/assets/cjs-in-browser-300x165.jpg&quot; alt=&quot;cjs-in-browser&quot; width=&quot;531&quot; height=&quot;301&quot; /&gt;&lt;/a&gt; --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/cjs-in-browser.jpg&quot; alt=&quot;cjs-in-browser&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The beauty of this API design – it uses “proper”, modern paradigms in the JavaScript part, i.e. async calls and cascading where possible.
```JavaScript
cjs.connector.connect(“http://172.16.2.172:57776/”, “Samples”, [“School2015”], function (cache) {
// creating a new object
 var p = new cache.School2015.Participant();
 p.Name = “Anton”;
 p.Surname = “Gnibeda”;
 p.$save(function(obj) {
   console.log(“Participant with name “ + obj.name + “ saved!”);
 });
// executing instance method
 cache.School2015.Group.openById(1, function (group) {
   group.PrintInfo(function (res) {
     console.log(res);
   });
 });
// executing linq-like queries
 cache.School2015.Participant
   .query()
   .where(“Carma &amp;lt; 100 OR Carma &amp;gt; 140”)
   .where(“$id &amp;gt; 10”)
   .orderByDesc(“Carma”)
   .orderBy(“Name”)
   .exec(function(res) {
     console.table(res);
   });
 });&lt;/p&gt;

&lt;h1&gt;2&lt;sup&gt;nd&lt;/sup&gt; place&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;As I already mentioned &lt;/em&gt;&lt;a href=&quot;http://writeimagejournal.com/?p=1902&quot;&gt;&lt;em&gt;as a preparation step to hackathon&lt;/em&gt;&lt;/a&gt;&lt;em&gt; we have formed a list of “interesting” task, which might be approached during hackathon. This was collected of Russian grants backlog and current GitHub projects backlog, with few additions of ideas from ISC employees.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;And it was a good surprise for us when 1 of topics from grant backlog list was selected as a hackathon projects – geo indices.&lt;/p&gt;

&lt;h2&gt;Geospatial — spatial indices in Caché&lt;/h2&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;321&quot;&gt;Team:&lt;/td&gt;
&lt;td width=&quot;1017&quot;&gt;&lt;a href=&quot;https://github.com/ARechitsky&quot;&gt;Andrey @Arechitsky Rechitsly&lt;/a&gt;, &lt;a href=&quot;https://github.com/adaptun&quot;&gt;Alexander @adaptun Koblov&lt;/a&gt;, &lt;a href=&quot;https://github.com/APogrebnikov&quot;&gt;Alexander @Apogrebnikov Pogrebnikov&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;321&quot;&gt;GitHub repo:&lt;/td&gt;
&lt;td width=&quot;1017&quot;&gt;&lt;a href=&quot;https://github.com/intersystems-ru/spatialindex&quot;&gt;https://github.com/intersystems-ru/spatialindex&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This was a long-standing request – we wanted that someone would implement support of geo spatial indices in Caché. There was no single reason why it could not be done eventually, given enough of expertise and opportunity. This hackathon was a good chance, because this team formed was overwhelmed with mathematics skills and COS expertise.&lt;/p&gt;

&lt;p&gt;Thanks to this project now we have custom indices which internally use quad-trees for given set of geo pairs. Also authors have demonstrated simple Angular application, which visualizes quick search for the given box on map, and this search takes fractions of seconds even for the multiple millions in dataset.&lt;/p&gt;

&lt;p&gt;In essence adding of such geospatial indices could be done this way:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Add index for the pair of properties (longitude, latitude):&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;Index x1f on (Latitude,Longitude) As SpatialIndex.Index;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
	&lt;li&gt;Search for the given box of coordinates&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;SELECT *
 FROM SpatialIndex.Test
 WHERE %ID %FIND search_index(x1F,'window','minx=56,miny=56,maxx=57,maxy=57')&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
	&lt;li&gt;Search for the given ellipse&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;SELECT *
 FROM SpatialIndex.Test
 WHERE  %ID %FIND search_index(x1F,'radius','x=55,y=55,radiusX=2,radiusY=2')
 and name %StartsWith 'Z'&lt;/pre&gt;

&lt;p&gt;This is only beginning of an implementation, obviously, and not in any case is pretending to be ISO 19125 compliant in this early development state. But that was an important 1&lt;sup&gt;st&lt;/sup&gt; step, and is already usable in the COS projects&lt;/p&gt;

&lt;p&gt;I am super excited about this particular project! It is not that polished as other winning projects, but could be influencing product in a long run…&lt;/p&gt;

&lt;h1&gt;3&lt;sup&gt;rd&lt;/sup&gt; place&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;We decided to give 3&lt;sup&gt;rd&lt;/sup&gt; place to 2 brilliant projects: call diagram visualizer and global map visualizer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And worth to note that both these projects were directly influenced by Nikita Savchecnko’ &lt;/em&gt;&lt;a href=&quot;https://github.com/intersystems-ru/UMLExplorer&quot;&gt;&lt;em&gt;UMLExplorer&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Callsmap —call diagram visualization&lt;/h2&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;320&quot;&gt;Team:&lt;/td&gt;
&lt;td width=&quot;824&quot;&gt;&lt;a href=&quot;https://github.com/doublefint&quot;&gt;Oleg @doublefint Dmitrovich&lt;/a&gt;, Evgenia Litvin, &lt;a href=&quot;https://github.com/TsvetkovAV&quot;&gt;Alexander @TsvetkovAV Tsvetokov&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;320&quot;&gt;GitHub repo:&lt;/td&gt;
&lt;td width=&quot;824&quot;&gt;&lt;a href=&quot;https://github.com/intersystems-ru/callsmap&quot;&gt;https://github.com/intersystems-ru/callsmap&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Oleg Dmitrovich liked how UMLExplorer visualized class hierarchy, and he wanted to extend it with call diagram functionality. They parse classes themselves, extracting method and function names, and then want to show call graph somehow. But unfortunately the components used in the UMLExplorer was not scalable enough to handle so many classes as Oleg had in their development namespaces (several thousand of classes, with the corresponding number of call edges). Thus he had to find another JavaScript component which could handle their situation and eventually they ended up using &lt;a href=&quot;https://github.com/anvaka/VivaGraphJS&quot;&gt;Viva Graph&lt;/a&gt;, which is &lt;em&gt;very fast&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In some of their namespaces call diagram “galaxy” could be visualized this way:&lt;/p&gt;

&lt;!-- &lt;a href=&quot;/assets/cache-galaxy.png&quot;&gt;&lt;img class=&quot;wp-image-1913 aligncenter&quot; src=&quot;/assets/cache-galaxy-300x252.png&quot; alt=&quot;cache-galaxy&quot; width=&quot;500&quot; height=&quot;423&quot; /&gt;&lt;/a&gt; --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/cache-galaxy.png&quot; alt=&quot;cache-galaxy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Static picture does not show the whole beauty of a visualized diagram (which has nice animation effect in &lt;a href=&quot;https://github.com/anvaka/VivaGraphJS&quot;&gt;Viva Graph&lt;/a&gt;, in real life this graph animation is really astonishing)&lt;/p&gt;

&lt;h2&gt;CacheBlocksExplorer — global tree and database map visualizer&lt;/h2&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;320&quot;&gt;Team:&lt;/td&gt;
&lt;td width=&quot;717&quot;&gt;&lt;a href=&quot;https://github.com/daimor&quot;&gt;Dmitry @daimor Maslennikov&lt;/a&gt;, Olga Kazantseva&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;320&quot;&gt;GitHub repo:&lt;/td&gt;
&lt;td width=&quot;717&quot;&gt;&lt;a href=&quot;https://github.com/intersystems-ru/CacheBlocksExplorer&quot;&gt;https://github.com/intersystems-ru/CacheBlocksExplorer&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Yet another project, which has been created on UMLExplorer engine — is that global tree, and database map visualizer created by Dmitry Maslennikov. Actually he had working &lt;em&gt;globals b*-tree visualizer&lt;/em&gt; even before hackathon started (as a side effect of one question he has been asked at the Vladivostock training he delivered before). But once he showed his project at the start of hackathon the consensus was that we all want database map just like in old school “Norton SpeedDisk”. So Dmitry has implemented just exactly that map in 1 night.&lt;/p&gt;

&lt;!-- &lt;a href=&quot;/assets/global-tree.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-1916&quot; src=&quot;/assets/global-tree-300x171.png&quot; alt=&quot;global-tree&quot; width=&quot;499&quot; height=&quot;290&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;/assets/disk-map.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-1915&quot; src=&quot;/assets/disk-map-300x171.png&quot; alt=&quot;disk-map&quot; width=&quot;499&quot; height=&quot;290&quot; /&gt;&lt;/a&gt; --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/global-tree.png&quot; alt=&quot;global-tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, as a side effect of this project development we have 2 very valuable tools, which might be useful both for education and for performance analysis.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;It will be one of my favorite tools, I guess.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Other noticeable projects&lt;/h1&gt;

&lt;p&gt;There were 3 more projects which got to the final pitching stage in various conditions. Most of them are long-standing projects, and will be probably mentioned later, once some notable development would happened and went online. Not today&lt;/p&gt;

&lt;p&gt;Here are their repositories in any case:&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;242&quot;&gt;CPM&lt;/td&gt;
&lt;td width=&quot;682&quot;&gt;&lt;a href=&quot;https://github.com/intersystems-ru/CPM&quot;&gt;https://github.com/intersystems-ru/CPM&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;242&quot;&gt;Atom COS Studio&lt;/td&gt;
&lt;td width=&quot;682&quot;&gt;&lt;a href=&quot;https://github.com/UGroup/Atom-COS-Studio&quot;&gt;https://github.com/UGroup/Atom-COS-Studio&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;242&quot;&gt;Arduino Snippets&lt;/td&gt;
&lt;td width=&quot;682&quot;&gt;&lt;a href=&quot;https://github.com/intersystems-ru/ArduinoSnippets&quot;&gt;https://github.com/intersystems-ru/ArduinoSnippets&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Now, several days after the hackathon completion we might derive cold hearty conclusions, and should admit that this hackathon experiment was more than successful, and produced 4 brilliant projects which will be of much help to community and to the product in a longer run.&lt;/p&gt;

&lt;p&gt;Ain’t it cool?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://plus.google.com/+TimurSafin1/posts/AN2JcP9K2yx&quot;&gt;https://plus.google.com/+TimurSafin1/posts/AN2JcP9K2yx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plus.google.com/+TimurSafin1/posts/9BMJjFAqmxn&quot;&gt;https://plus.google.com/+TimurSafin1/posts/9BMJjFAqmxn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/groups/mskiscmeetup/permalink/1056669757706535/&quot;&gt;https://www.facebook.com/groups/mskiscmeetup/permalink/1056669757706535/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">[Русская версия статьи изначально опубликована на Хабре здесь]</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://tsafin.net/%7B%22feature%22=%3E%22landscapes/feature3.jpg%22,%20%22credits%22=%3Enil%7D" /></entry></feed>