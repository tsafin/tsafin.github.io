<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации • Timur Safin - Making No Sense</title>
    <meta name="description" content="
  В предыдущей части серии мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).


">
    <meta name="keywords" content="">
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации">
	<meta name="twitter:description" content="
  В предыдущей части серии мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).


">
	<meta name="twitter:site" content="@tsafin">
	<meta name="twitter:creator" content="@tsafin">
	
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:image" content="/images/landscapes/feature6.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации">
	<meta property="og:description" content="
  В предыдущей части серии мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).


">
	<meta property="og:url" content="/blog/mapreduce/mapreduce-russian-part-ii/">
	<meta property="og:site_name" content="Timur Safin - Making No Sense">

    <link rel="canonical" href="/blog/mapreduce/mapreduce-russian-part-ii/">

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Timur Safin - Making No Sense Atom Feed">
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <link rel="stylesheet" href="/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="/js/vendor/html5shiv.min.js"></script>
      <script src="/js/vendor/respond.min.js"></script>
    <![endif]-->
  </head>

  <body id="js-body">
    <!--[if lt IE 9]><div class="upgrade notice-warning"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

    <header id="masthead">
  <div class="inner-wrap">
    <a href="/" class="site-title">Timur Safin - Making No Sense</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Timur Safin - Making No Sense</a></li>
	 
      
      <li><a href="/blog/" >Articles</a></li>
    
      
      <li><a href="/projects/" >Projects</a></li>
    
      
      <li><a href="/resume/" >About</a></li>
    
</ul>
    </nav>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->
    <nav role="navigation" id="js-menu" class="sliding-menu-content">
  <h5>Timur Safin - Making No Sense <span>Table of Contents</span></h5>
  <ul class="menu-item">
    <li>
      <a href="/blog/">
        
        <div class="title">Articles</div>
        <p class="excerpt">Blog posts and random rumblings...</p>
      </a>
    </li><li>
      <a href="/projects/">
        
        <div class="title">Projects</div>
        <p class="excerpt">Open-source projects</p>
      </a>
    </li><li>
      <a href="/resume/">
        
        <div class="title">About</div>
        <p class="excerpt">Resume and such...</p>
      </a>
    </li>
  </ul>
</nav>
<button type="button" id="js-menu-trigger" class="sliding-menu-button lines-button x2" role="button" aria-label="Toggle Navigation">
  <span class="nav-lines"></span>
</button>

<div id="js-menu-screen" class="menu-screen"></div>


    <div id="page-wrapper">
      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="/images/landscapes/feature6.jpg" class="page-feature-image" alt="Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации" itemprop="image">
				
			</div><!-- /.page-image -->
		</div><!-- /.page-feature -->
		
		
<nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://tsafin.net" itemprop="url">
        <span itemprop="title">Home</span>
    </a> ›
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="/blog/" itemprop="url">
        <span itemprop="title">Blog</span>
    </a>
    </span>
</nav>
<!-- /.breadcrumbs -->


<div class="breadcrumbs sm">
    <a href="https://habrahabr.ru/company/intersystems/blog/310196/" itemprop="url">
        https://habrahabr.ru/company/intersystems/blog/310196/&nbsp;<span class="glyphicon glyphicon-share" aria-hidden="true"></span>
    </a>
</div>

		<div class="page-title">
			<h1>Еще раз про MapReduce. Часть 2 – базовые интерфейсы реализации</h1>
		</div>
		<div class="inner-wrap">
			<div id="content" class="page-content" itemprop="articleBody">
				<blockquote>
  <p><em><a href="http://fineartamerica.com/featured/take-it-like-a-man-joan-pollak.html"><img src="https://habrastorage.org/files/e4c/cac/f03/e4ccacf0316840bca92ee668bfdb1f95.jpg" align="left" width="288" height="240" alt="Take it like a man by Joan Pollak" /></a><a href="../mapreduce-russian-part-i/">В предыдущей части серии</a> мы (в 100500й раз) попытались рассказать про основные приемы и стадии подхода Google MapReduce, должен признаться, что первая часть была намерено “капитанской”, чтобы дать знать о MapReduce целевой аудитории последующих статей. Мы не успели показать ни строчки того, как всё это мы собираемся реализовывать в Caché ObjectScript. И про это наша рассказ сегодня (и в последующие дни).</em></p>
</blockquote>

<p>Напомним первоначальный посыл нашего мини-проекта: вы всё еще планируем реализовать MapReduce алгоритм используя те подручные средства, что есть в Caché ObjectScript. При создании интерфейсов, мы попытаемся придерживаться того API, что мы описали в предыдущей статье про оригинальную реализацию Google MapReduce, любые девиации будут озвучены соответствующе.</p>
<habracut />

<p>Начнем с реализации абстрактных интерфейсов Mapper и Reducer.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Class MR.Base.Mapper 
{
Method Map(MapInput As MR.Base.Iterator, MapOutput As MR.Base.Emitter) [ Abstract ] { }
}

Class MR.Base.Reducer
{
Method Reduce(ReduceInput As MR.Base.Iterator, ReduceOutput As MR.Base.Emitter) [ Abstract ] { }
}
</code></pre></div></div>

<p>Изначально, как и в канонической реализации, мы сделали 2 отдельных интерфейса MapInput и ReduceInput. Но сразу стало очевидным, что они служат одной и той же цели, и предоставляют одни и те же методы – их цель пройтись по потоку данных до конца, т.ч. они оба являются итераторами. Потому, в итоге, редуцируем их в общий интерфейс MR.Base.Iterator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Class MR.Base.Iterator
{

Method GetNext() As %String [Abstract ] { }

Method IsAtEnd() As %Boolean [Abstract ] { }

}
</code></pre></div></div>

<h2 id="использование-глобалов-в-качестве-каналов-связи">Использование глобалов в качестве каналов связи</h2>

<p>Оригинальная реализация Google MapReduce использовала файловую систему Google GFS как транспорт между узлами и стадиями алгоритма. В Caché есть свой механизм распространения (когерентных) данных между узлами (если не пользоваться голым TCP/UDP) – это протокол ECP (<a href="http://docs.intersystems.com/documentation/cache/latest/pdfs/GDDM.pdf">Enterprise Caсhe Protocol</a>). Обычно он используется серверами приложений для получения данных от удаленных серверов баз данных. Но ничего не останавливает нас от построения на базе таких peer-to-peer соединений ECP некоей виртуальной управляющей шины, куда мы будем складывать данные в виде пар &lt;ключ,значение&gt; или похожие данные. Эти данные будут будут пересылаться между акторами, участвующими в конвейерах алгоритма (т.е. emit, посылаемый объектом Mapper, будет писаться в шину ECP и читаться объектом Reducer). Если акторы будут работать в рамках одного узла, то они, например могут использовать быстрые глобалы, отображенные в CACHETEMP, или обычные глобалы, если реализуемый алгоритм многостадийный и нужна надежность и журналирование.</p>

<p>В любом случае, будь то локальные (для конфигурации на одном узле) глобалы, или глобалы удаленного узла, подключенного через ECP, глобалы являются удобным и хорошо зарекомендовавшим себя транспортом для передачи данных между узлами кластера Caché, в данном случае, между вовлеченными в MapReduce функциями и классами.</p>

<blockquote>
  <p>Посему, естественным решением, позволяющим упростить нашу систему будет использование в среде Caché для передачи данных между узлами кластера протокола ECP вместо файловых систем GFS или HDFS. Функциональные характеристики ECP позволят сделать и другие упрощения (но об этом несколько позже).</p>
</blockquote>

<h2 id="эмиттеры-и-черная-магия">Эмиттеры и черная магия</h2>

<p>Как мы уже рассказывали <a href="https://habrahabr.ru/company/intersystems/blog/310180/">в предыдущей серии</a>, с момента когда данные уходят от объекта Mapper, и до момента как они поступают на вход Reducer, в классической реализации на мастере проходит тяжелая операция перемешения и сортировки.</p>

<p>В окружении, использующем глобалы к качестве транспорта, в MUMPS/Caché ObjectScript среде, мы можем полностью избежать дополнительных расходов на такую сортировку, т.к. агрегация и сортировка будут сделаны нижележащим btree* хранилищем.</p>

<p>Имея такие требования к дизайну, создадим базовый интерфейс эмиттера:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Class MR.Base.Emitter Extends MR.Base.Iterator
{

/// emit $listbuild(key,value(s))
Method Emit(EmitList... As %String) [Abstract ] { }

}
</code></pre></div></div>

<p>Эмиттер должен быть похож на интерфейс входного итератора, показанного выше (потому мы и пронаследовались от MR.Base.Iterator), но в дополнение к интерфейсу прохода по данным, эмиттер должен уметь еще и посылать данные в своё промежуточное хранилище (т.е. добавляем функцию Emit).</p>

<p>Первоначально, наша функция Emit была очень похожа на классическую реализацию и принимала только 2 аргумента как пару &lt;ключ,значение&gt;, но потом мы натолкнулись на (редкую) необходимость передавать что-то более многомерное, длиннее чем пара значений (например, кортеж любой арности), потому, в настоящий момент, Emit стал функцией принимающей переменное число аргументов.</p>

<p>Заметим, что в большинстве случаев, на практике, сюда будет поступать только пара аргументов &lt;ключ,значение&gt; как мы и видели в классической реализации.</p>

<p><em>Это всё ещё абстрактный интерфейс, больше мяса будет добавлено очень скоро.</em></p>

<p>Если бы нам, при обработке, надо было сохранять порядок поступивших элементов, то мы бы использовали реализацию ниже:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
/// Emitter which maintains the order of (key,value(s))
Class MR.Emitter.Ordered Extends (%RegisteredObject, MR.Base.Emitter)
{
   /// global name serving as data channel
Property GlobalName As %String;
Method %OnNew(initval As %String) As %Status
{
    $$$ThrowOnError($length(initval)&gt;0)
    set ..GlobalName = initval 
    quit $$$OK
}

Parameter AUTOCLEANUP = 1;
Method %OnClose() As %Status
{
    if ..#AUTOCLEANUP {
        if $data(@i%GlobalName) {
            kill @i%GlobalName
        }
    }
    Quit $$$OK
}
...
}
</code></pre></div></div>

<p>Заметим на полях, что в Caché глобалы – в общем-то, глобальны :) , и не будут очищены автоматически по завершении процессов их создавших. В отличие, например, от <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GCOS_variables#GCOS_variables_procprivglbls">PPG (process-private globals)</a>. Но иногда все же хочется, чтобы наши промежуточные каналы, созданные для взаимодействия между стадиями конвейера MapReduce удалялись по завершении подпрограммы их создавшей. Поэтому и был добавлен режим “автоочистки” (параметр класса #AUTOCLEANUP) при котором глобал, имя которого хранится в свойстве GlobalName, будет удален при закрытии объекта (в момент вызова %OnClose).</p>

<p>Обратите внимание, что мы форсируем один обязательный параметр в метода %New (в %OnNew генерируем $$$ThrowOnError если имя в Initval не определено). Конструктор класса ожидает получить название глобала с которым он будет работать в качестве транспорта данных.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Class MR.Emitter.Ordered Extends MR.Base.Emitter
{
/// ... 
Method IsAtEnd() As %Boolean
{
    quit ($data(@i%GlobalName)\10)=0
}

/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim list As %String = ""
    for i=1:1:$get(EmitList) {
        set $li(list,i) = $get(EmitList(i))
    }
    #dim name As %String = ..GlobalName
    set @name@($seq(@name)) = list
}

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim value As %String
    #dim index As %String = $order(@i%GlobalName@(""), 1, value)

    if index '= "" {
        kill @i%GlobalName@(index)
        quit value
    } else {
        kill @i%GlobalName
        quit ""
    }
}

Method Dump()
{
    zwrite @i%GlobalName
}

}
</code></pre></div></div>

<p>Надеемся, вы еще помните, что наш Emitter является наследником итератора Iterator? Посему ему нужно реализовать пару функций итератора – IsAtEnd и GetNext.</p>

<ul>
  <li>
    <p>IsAtEnd – простой: если наш служебный глобал не содержит данных (т.е. <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RVBS_fdata">$data(..GlobalName)</a> не возвращает 10 или 11, что означает что там в поддереве есть еще узлы с данными), то мы достигли конца потока данных;</p>
  </li>
  <li>
    <p>Emit создает узел с данными в конце текущего списка. Оформляя пару (или кортеж, при арности больше 2х) как элемент <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RSQL_d_listbuild">$(listbuild(…))</a> [listbuild].</p>
  </li>
</ul>

<p>Как известно, и как хорошо написал <a href="https://habrahabr.ru/company/intersystems/blog/263793/">Саша Коблов, $SEQUENCE</a> может быть использована почти во всех местах, где использовался <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fincrement">$INCREMENT</a>, обеспечивая при этом лучшие скорости при работе в многопроцессорном или многосерверном режиме (через ECP). В силу меньшего количества коллизий при обращении к одном узлу глобала. Потому в коде выше мы используем <em>$sequence</em> для выделения индекса следующего элемента упорядоченного списка.</p>

<ul>
  <li>На другой стороне алгоритма, в получателе GetNext() вытаскивает элементы из коллекции посредством простого <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_forder">$ORDER(@i%GlobalName(“”))</a>. Элемент, с полученным индексом будет удален из списка после обработки.</li>
</ul>

<blockquote>
  <p><em>Обращаем внимание, что данный вариант удаления элемента из списка/глобала <a href="https://community.intersystems.com/post/cach%C3%A9-mapreduce-basic-interfaces-mapreduce-implementation-part-ii#comments">не очень совместим с параллельным режимом</a>, и нужно было бы добавить блокировки или сменить структуру данных. Но т.к. на ближайшие серии у нас будет только один Reducer, на всё множество Mapper ов, то мы отложим решение данной проблемы на будущее, когда приступим к много-серверной реализации.</em></p>
</blockquote>

<blockquote>
  <p>Заметим, что структура данных, реализованная MR.Emitter.Ordered по сути реализуют классическую коллекцию FIFO ("FirstIn – FirstOut"). Мы помещаем новый элемент в конец списка и вытаскиваем из головы списка.</p>
</blockquote>

<h3 id="специальный-случай-эмиттер-с-автоагрегацией">Специальный случай: эмиттер с автоагрегацией</h3>

<p>Если вы посмотрите на те данные, что мы посылаем в между стадиями конвейера в примере word-count (ок, не сейчас, а когда мы вам покажем такую реализацию) то вы быстро осознаете, что:</p>

<ul>
  <li>
    <p>На самом деле нам не интересен порядок, в котором мы “эмиттим”  пары &lt;ключ, значение&gt;. Более того, нижележащее хранилище btree* всегда держит список ключей отсортированным для быстрого поиска, избавляя нас от необходимости сортировки на мастере, как произошло бы в классической реализации;</p>
  </li>
  <li>
    <p>И в наших случаях, когда мы пишем пару &lt;key,1&gt; на стороне Mapper, мы предполагаем в Reducer их простую агрегацию в сумму единиц. Т.е. в случае Caché ObjectScript мы полагались бы на использование <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fincrement">$INCREMENT</a>.</p>
  </li>
</ul>

<blockquote>
  <p><em>Так зачем посылать такой большой трафик ненужных данных, если мы можем их агрегировать еще в момент посылки?</em></p>
</blockquote>

<p>Именно так и работает MR.Emitter.Sorted, который является наследником MR.Emitter.Ordered (показанного выше):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
/// Emitter which sorts by keys all emitted pairs or tuples (key, value(s))
Class MR.Emitter.Sorted Extends MR.Emitter.Ordered
{
Property AutoIncrement As %Boolean [ InitialExpression = 1 ];
/// emit $listbuild(key,value)
Method Emit(EmitList... As %String)
{
    #dim name As %String = ..GlobalName
    #dim key As %String
    #dim value As %String 

    if $get(EmitList)=1 {
        // special case - only key name given, no value
        set key = $get(EmitList(1))
        quit:key=""
        if ..AutoIncrement {
            #dim dummyX As %Integer = $increment(@name@(key)) ; $seq is non-deterministic
        } else {
            set @name@(key) = 1
        }
    } else {
        set value = $get(EmitList(EmitList))
        set EmitList = EmitList - 1
        for i=1:1:$get(EmitList) {
            #dim index As %String = $get(EmitList(i))
            quit:index=""
            set name = $name(@name@(index))
        }
        if ..AutoIncrement {
            #dim dummyY As %Integer = $increment(@name,value)
        } else {
            set @name = value
        }
    }
}
/// ...
}
</code></pre></div></div>

<p>Для самого простого случая, выдачи пары &lt;key,1&gt; или, когда значение опущено, и имеет один ключ &lt;key&gt; мы реализовали локальную оптимизацию, когда в режиме автоинкремента (AutoIncrement = 1) мы при вызове сразу инкрементируем соответствующий счетчик для ключа. Если же не включен автоинкремент, то мы просто (пере)определяем узел ключа в 1, фиксируя факт передачи ключа.</p>

<p>Для более общего случая, с двумя элементами, пары ключ-значение &lt;key,value&gt; или даже с большим количеством элементов &lt;key,key2,key3,…keyn,value&gt; (кортеж любой арности) у нас опять же реализовано 2 режима работы:</p>

<ul>
  <li>
    <p>при <em>автоинкременте</em> мы сразу суммируем значение соответствующего узла, адресуемого ключом(ключами) с переданным значением;</p>
  </li>
  <li>
    <p>и <em>без автоинкремента</em> – мы присваиваем соответствующему узлу, адресуемому данным списком ключей, переданное значение value.</p>
  </li>
</ul>

<p>Обращаем внимание, что кортеж мы передаем посредством массива, аккумулирующего переменное количество аргументов. Все элементы этого массива кроме последнего, пойдут как адреса <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_structure#GGBL_structure_nodes_and_subscripts">подындексов</a>. Последний элемент кортежа будет считаться значением.</p>

<blockquote>
  <p><em>Такое необычное расширение пары «ключ-значение» в кортежи любой мощности, по нашим сведениям, является нетипичным или может быть уникальным. Нам не надо работать со строгим key-value хранилищем или bigtable хранилищем, и мы с легкостью можем работать с многомерными ключами в передаваемых элементах (“потому что можем”), что может сильно облегчить некоторые реализации алгоритмов, требующих дополнительной размерности данных, что сильно улучшает читабельность кода и упрощает понимание. В теории…</em></p>
</blockquote>

<p>Заметим, что мы не переопределили IsAtEnd и он пронаследовал реализацию из MR.Emitter.Ordered, таким образом он по-прежнему будет возвращать ненулевое значение по окончании данных в подузлах промежуточного хранилища.</p>

<p>Но GetNext нам надо переопределить, т.к. мы больше не пытаемся запомнить порядок посланных данных и формат его внутреннего хранилища поменялся:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Class MR.Emitter.Sorted Extends MR.Emitter.Ordered 
{
/// ...

/// returns emitted $lb(key,value)
Method GetNext() As %String
{
    #dim name As %String = ..GlobalName
    #dim value As %String
    #dim ref As %String = $query(@name,1,value)
    if ref'="" {
        zkill @ref
        #dim i As %Integer
        #dim refLen As %Integer = $qlength(ref)
        #dim baseLen As %Integer = $qlength(name)
        #dim listbuild = ""
        for i=baseLen+1:1:refLen {
            set $li(listbuild,i-baseLen)=$qs(ref,i)
        }
        set $li(listbuild,*+1)=value

        quit listbuild
    }

    quit ""
}

}

</code></pre></div></div>

<p>На выходе из GetNext() мы ожидаем <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_flistbuild">$LISTBUILD&lt;&gt;</a> список, но внутри хранилища данные пар/кортежей разбросаны по узлам иерархического хранилища. Функция <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fquery">$QUERY</a> позволяет обойти узлы с данными (значениями пар/кортежей) в массиве для последующей их перепаковки в $LISTBUILD формат, индексы из массива последовательно добавляются следующим элементом списка (посредством присваивания элементу через функцию <a href="http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_flist">$LIST</a>. Само же значение узла хранилища (значение в паре «ключ-значение» или последний элемент кортежа) будет добавлено в конец сформированного списка через ту же функцию $LIST(listbuild,*+1). В данном случае *+1 как раз и обозначат номер элемента списка, следующий за текущим концом.</p>

<blockquote>
  <p><em>На этом неожиданном месте мы прервем наш рассказ про MapReduce в Caché. Во второй части данного повествования мы показали базовые интерфейсы инфраструктуры, которые будут использованы в дальнейшем при реализации конкретных примеров. Уже в следующей серии мы соберем это всё воедино и реализуем классический пример WordCount, но уже на ObjectScript. Не уходите далеко!</em></p>
</blockquote>

				<hr />
				<footer class="page-footer">
					

<div class="author-image">
    <img src="/images/tsafin_twitter_small_logo.jpg" alt="Timur Safin">
</div>
<!-- ./author-image -->
<div class="author-content">
    <h3 class="author-name">Written by <span itemprop="author">Timur Safin</span></h3>
    <p class="author-bio"></p>
</div>
<!-- ./author-content -->
					<div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=Еще%20раз%20про%20MapReduce.%20Часть%202%20–%20базовые%20интерфейсы%20реализации&amp;url=/blog/mapreduce/mapreduce-russian-part-ii/&amp;via=tsafin" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> Share on Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=/blog/mapreduce/mapreduce-russian-part-ii/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> Share on Facebook</a>
	<a class="btn-social google-plus"  href="https://plus.google.com/share?url=/blog/mapreduce/mapreduce-russian-part-ii/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> Share on Google+</a>
</div><!-- /.share-this -->

					<div class="page-meta">
	<p>Updated <time datetime="2016-10-04T10:24:00Z" itemprop="datePublished">October 04, 2016</time></p>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname = 'tsafin-net';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->

      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="/" >Home</a></li>
		
      
			<li><a href="/blog/" >Articles</a></li>
		
      
			<li><a href="/projects/" >Projects</a></li>
		
      
			<li><a href="/about/" >About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2020 <a href="http://tsafin.net">Timur Safin - Making No Sense</a> powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> + <a href="http://mmistakes.github.io/skinny-bones-jekyll/" rel="nofollow">Skinny Bones</a>.</p>
</footer>

    </div>

    <script src="/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="/js/main.js"></script>

    

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-84704404-1', 'auto');
  ga('require', 'linkid');
  ga('send', 'pageview');

</script>


<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter40768979 = new Ya.Metrika({
                    id:40768979,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/40768979" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->



  </body>

</html>
